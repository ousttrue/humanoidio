# this is generated by sukonbu
from typing import NamedTuple, List, Any, Optional, Dict
from enum import Enum

def is_enable(value):
    if isinstance(value, int):
        return True
    if value:
        return True
    return False


class AccessorComponentType(Enum):
    BYTE = 5120
    UNSIGNED_BYTE = 5121
    SHORT = 5122
    UNSIGNED_SHORT = 5123
    UNSIGNED_INT = 5125
    FLOAT = 5126

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AccessorComponentType':
        dst = {}
        return AccessorComponentType(dst)


class AccessorType(Enum):
    SCALAR = "SCALAR"
    VEC2 = "VEC2"
    VEC3 = "VEC3"
    VEC4 = "VEC4"
    MAT2 = "MAT2"
    MAT3 = "MAT3"
    MAT4 = "MAT4"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AccessorType':
        dst = {}
        return AccessorType(dst)


class AccessorSparseIndicesComponentType(Enum):
    UNSIGNED_BYTE = 5121
    UNSIGNED_SHORT = 5123
    UNSIGNED_INT = 5125

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AccessorSparseIndicesComponentType':
        dst = {}
        return AccessorSparseIndicesComponentType(dst)


class AccessorSparseIndices(NamedTuple):
    # The index of the bufferView with sparse indices. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
    bufferView: int
    # The indices data type.
    componentType: AccessorSparseIndicesComponentType
    # The offset relative to the start of the bufferView in bytes. Must be aligned.
    byteOffset: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.bufferView): d["bufferView"] = self.bufferView # noqa
        if is_enable(self.byteOffset): d["byteOffset"] = self.byteOffset # noqa
        if is_enable(self.componentType): d["componentType"] = self.componentType.to_dict() # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AccessorSparseIndices':
        dst = {}
        if "bufferView" in src: dst["bufferView"] = src["bufferView"] # noqa copy
        if "byteOffset" in src: dst["byteOffset"] = src["byteOffset"] # noqa copy
        if "componentType" in src: dst["componentType"] = AccessorSparseIndicesComponentType(src["componentType"]) # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return AccessorSparseIndices(**dst)


class AccessorSparseValues(NamedTuple):
    # The index of the bufferView with sparse values. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
    bufferView: int
    # The offset relative to the start of the bufferView in bytes. Must be aligned.
    byteOffset: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.bufferView): d["bufferView"] = self.bufferView # noqa
        if is_enable(self.byteOffset): d["byteOffset"] = self.byteOffset # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AccessorSparseValues':
        dst = {}
        if "bufferView" in src: dst["bufferView"] = src["bufferView"] # noqa copy
        if "byteOffset" in src: dst["byteOffset"] = src["byteOffset"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return AccessorSparseValues(**dst)


class AccessorSparse(NamedTuple):
    # Number of entries stored in the sparse array.
    count: int
    # Indices of those attributes that deviate from their initialization value.
    indices: AccessorSparseIndices
    # Array of size `accessor.sparse.count` times number of components storing the displaced accessor attributes pointed by `accessor.sparse.indices`.
    values: AccessorSparseValues
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.count): d["count"] = self.count # noqa
        if is_enable(self.indices): d["indices"] = self.indices.to_dict() # noqa
        if is_enable(self.values): d["values"] = self.values.to_dict() # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AccessorSparse':
        dst = {}
        if "count" in src: dst["count"] = src["count"] # noqa copy
        if "indices" in src: dst["indices"] = AccessorSparseIndices.from_dict(src["indices"]) # noqa
        if "values" in src: dst["values"] = AccessorSparseValues.from_dict(src["values"]) # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return AccessorSparse(**dst)


class Accessor(NamedTuple):
    # The datatype of components in the attribute.
    componentType: AccessorComponentType
    # The number of attributes referenced by this accessor.
    count: int
    # Specifies if the attribute is a scalar, vector, or matrix.
    type: AccessorType
    # The index of the bufferView.
    bufferView: Optional[int] = None
    # The offset relative to the start of the bufferView in bytes.
    byteOffset: Optional[int] = None
    # Specifies whether integer data values should be normalized.
    normalized: Optional[bool] = None
    # Maximum value of each component in this attribute.
    max: Optional[List[float]] = None
    # Minimum value of each component in this attribute.
    min: Optional[List[float]] = None
    # Sparse storage of attributes that deviate from their initialization value.
    sparse: Optional[AccessorSparse] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.bufferView): d["bufferView"] = self.bufferView # noqa
        if is_enable(self.byteOffset): d["byteOffset"] = self.byteOffset # noqa
        if is_enable(self.componentType): d["componentType"] = self.componentType.to_dict() # noqa
        if is_enable(self.normalized): d["normalized"] = self.normalized # noqa
        if is_enable(self.count): d["count"] = self.count # noqa
        if is_enable(self.type): d["type"] = self.type.to_dict() # noqa
        if self.max: d["max"] = self.max # noqa
        if self.min: d["min"] = self.min # noqa
        if is_enable(self.sparse): d["sparse"] = self.sparse.to_dict() # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Accessor':
        dst = {}
        if "bufferView" in src: dst["bufferView"] = src["bufferView"] # noqa copy
        if "byteOffset" in src: dst["byteOffset"] = src["byteOffset"] # noqa copy
        if "componentType" in src: dst["componentType"] = AccessorComponentType(src["componentType"]) # noqa
        if "normalized" in src: dst["normalized"] = src["normalized"] # noqa copy
        if "count" in src: dst["count"] = src["count"] # noqa copy
        if "type" in src: dst["type"] = AccessorType(src["type"]) # noqa
        dst["max"] = src.get("max", [])
        dst["min"] = src.get("min", [])
        if "sparse" in src: dst["sparse"] = AccessorSparse.from_dict(src["sparse"]) # noqa
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Accessor(**dst)


class AnimationChannelTargetPath(Enum):
    translation = "translation"
    rotation = "rotation"
    scale = "scale"
    weights = "weights"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AnimationChannelTargetPath':
        dst = {}
        return AnimationChannelTargetPath(dst)


class AnimationChannelTarget(NamedTuple):
    # The name of the node's TRS property to modify, or the "weights" of the Morph Targets it instantiates. For the "translation" property, the values that are provided by the sampler are the translation along the x, y, and z axes. For the "rotation" property, the values are a quaternion in the order (x, y, z, w), where w is the scalar. For the "scale" property, the values are the scaling factors along the x, y, and z axes.
    path: AnimationChannelTargetPath
    # The index of the node to target.
    node: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.node): d["node"] = self.node # noqa
        if is_enable(self.path): d["path"] = self.path.to_dict() # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AnimationChannelTarget':
        dst = {}
        if "node" in src: dst["node"] = src["node"] # noqa copy
        if "path" in src: dst["path"] = AnimationChannelTargetPath(src["path"]) # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return AnimationChannelTarget(**dst)


class AnimationChannel(NamedTuple):
    # The index of a sampler in this animation used to compute the value for the target.
    sampler: int
    # The index of the node and TRS property that an animation channel targets.
    target: AnimationChannelTarget
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.sampler): d["sampler"] = self.sampler # noqa
        if is_enable(self.target): d["target"] = self.target.to_dict() # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AnimationChannel':
        dst = {}
        if "sampler" in src: dst["sampler"] = src["sampler"] # noqa copy
        if "target" in src: dst["target"] = AnimationChannelTarget.from_dict(src["target"]) # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return AnimationChannel(**dst)


class AnimationSamplerInterpolation(Enum):
    LINEAR = "LINEAR"
    STEP = "STEP"
    CUBICSPLINE = "CUBICSPLINE"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AnimationSamplerInterpolation':
        dst = {}
        return AnimationSamplerInterpolation(dst)


class AnimationSampler(NamedTuple):
    # The index of an accessor containing keyframe input values, e.g., time.
    input: int
    # The index of an accessor, containing keyframe output values.
    output: int
    # Interpolation algorithm.
    interpolation: Optional[AnimationSamplerInterpolation] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.input): d["input"] = self.input # noqa
        if is_enable(self.interpolation): d["interpolation"] = self.interpolation.to_dict() # noqa
        if is_enable(self.output): d["output"] = self.output # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AnimationSampler':
        dst = {}
        if "input" in src: dst["input"] = src["input"] # noqa copy
        if "interpolation" in src: dst["interpolation"] = AnimationSamplerInterpolation(src["interpolation"]) # noqa
        if "output" in src: dst["output"] = src["output"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return AnimationSampler(**dst)


class Animation(NamedTuple):
    # An array of channels, each of which targets an animation's sampler at a node's property. Different channels of the same animation can't have equal targets.
    channels: List[AnimationChannel]
    # An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target).
    samplers: List[AnimationSampler]
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.channels: d["channels"] = [item.to_dict() for item in self.channels] # noqa
        if self.samplers: d["samplers"] = [item.to_dict() for item in self.samplers] # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Animation':
        dst = {}
        dst["channels"] = [AnimationChannel.from_dict(item) for item in src["channels"]] if "channels" in src else [] # noqa
        dst["samplers"] = [AnimationSampler.from_dict(item) for item in src["samplers"]] if "samplers" in src else [] # noqa
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Animation(**dst)


class Asset(NamedTuple):
    # The glTF version that this asset targets.
    version: str
    # A copyright message suitable for display to credit the content creator.
    copyright: Optional[str] = None
    # Tool that generated this glTF model.  Useful for debugging.
    generator: Optional[str] = None
    # The minimum glTF version that this asset targets.
    minVersion: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.copyright): d["copyright"] = self.copyright # noqa
        if is_enable(self.generator): d["generator"] = self.generator # noqa
        if is_enable(self.version): d["version"] = self.version # noqa
        if is_enable(self.minVersion): d["minVersion"] = self.minVersion # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Asset':
        dst = {}
        if "copyright" in src: dst["copyright"] = src["copyright"] # noqa copy
        if "generator" in src: dst["generator"] = src["generator"] # noqa copy
        if "version" in src: dst["version"] = src["version"] # noqa copy
        if "minVersion" in src: dst["minVersion"] = src["minVersion"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Asset(**dst)


class Buffer(NamedTuple):
    # The length of the buffer in bytes.
    byteLength: int
    # The uri of the buffer.
    uri: Optional[str] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.uri): d["uri"] = self.uri # noqa
        if is_enable(self.byteLength): d["byteLength"] = self.byteLength # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Buffer':
        dst = {}
        if "uri" in src: dst["uri"] = src["uri"] # noqa copy
        if "byteLength" in src: dst["byteLength"] = src["byteLength"] # noqa copy
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Buffer(**dst)


class BufferViewTarget(Enum):
    ARRAY_BUFFER = 34962
    ELEMENT_ARRAY_BUFFER = 34963

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'BufferViewTarget':
        dst = {}
        return BufferViewTarget(dst)


class BufferView(NamedTuple):
    # The index of the buffer.
    buffer: int
    # The total byte length of the buffer view.
    byteLength: int
    # The offset into the buffer in bytes.
    byteOffset: Optional[int] = None
    # The stride, in bytes.
    byteStride: Optional[int] = None
    # The target that the GPU buffer should be bound to.
    target: Optional[BufferViewTarget] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.buffer): d["buffer"] = self.buffer # noqa
        if is_enable(self.byteOffset): d["byteOffset"] = self.byteOffset # noqa
        if is_enable(self.byteLength): d["byteLength"] = self.byteLength # noqa
        if is_enable(self.byteStride): d["byteStride"] = self.byteStride # noqa
        if is_enable(self.target): d["target"] = self.target.to_dict() # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'BufferView':
        dst = {}
        if "buffer" in src: dst["buffer"] = src["buffer"] # noqa copy
        if "byteOffset" in src: dst["byteOffset"] = src["byteOffset"] # noqa copy
        if "byteLength" in src: dst["byteLength"] = src["byteLength"] # noqa copy
        if "byteStride" in src: dst["byteStride"] = src["byteStride"] # noqa copy
        if "target" in src: dst["target"] = BufferViewTarget(src["target"]) # noqa
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return BufferView(**dst)


class CameraOrthographic(NamedTuple):
    # The floating-point horizontal magnification of the view. Must not be zero.
    xmag: float
    # The floating-point vertical magnification of the view. Must not be zero.
    ymag: float
    # The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`.
    zfar: float
    # The floating-point distance to the near clipping plane.
    znear: float
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.xmag): d["xmag"] = self.xmag # noqa
        if is_enable(self.ymag): d["ymag"] = self.ymag # noqa
        if is_enable(self.zfar): d["zfar"] = self.zfar # noqa
        if is_enable(self.znear): d["znear"] = self.znear # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'CameraOrthographic':
        dst = {}
        if "xmag" in src: dst["xmag"] = src["xmag"] # noqa copy
        if "ymag" in src: dst["ymag"] = src["ymag"] # noqa copy
        if "zfar" in src: dst["zfar"] = src["zfar"] # noqa copy
        if "znear" in src: dst["znear"] = src["znear"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return CameraOrthographic(**dst)


class CameraPerspective(NamedTuple):
    # The floating-point vertical field of view in radians.
    yfov: float
    # The floating-point distance to the near clipping plane.
    znear: float
    # The floating-point aspect ratio of the field of view.
    aspectRatio: Optional[float] = None
    # The floating-point distance to the far clipping plane.
    zfar: Optional[float] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.aspectRatio): d["aspectRatio"] = self.aspectRatio # noqa
        if is_enable(self.yfov): d["yfov"] = self.yfov # noqa
        if is_enable(self.zfar): d["zfar"] = self.zfar # noqa
        if is_enable(self.znear): d["znear"] = self.znear # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'CameraPerspective':
        dst = {}
        if "aspectRatio" in src: dst["aspectRatio"] = src["aspectRatio"] # noqa copy
        if "yfov" in src: dst["yfov"] = src["yfov"] # noqa copy
        if "zfar" in src: dst["zfar"] = src["zfar"] # noqa copy
        if "znear" in src: dst["znear"] = src["znear"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return CameraPerspective(**dst)


class CameraType(Enum):
    perspective = "perspective"
    orthographic = "orthographic"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'CameraType':
        dst = {}
        return CameraType(dst)


class Camera(NamedTuple):
    # Specifies if the camera uses a perspective or orthographic projection.
    type: CameraType
    # An orthographic camera containing properties to create an orthographic projection matrix.
    orthographic: Optional[CameraOrthographic] = None
    # A perspective camera containing properties to create a perspective projection matrix.
    perspective: Optional[CameraPerspective] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.orthographic): d["orthographic"] = self.orthographic.to_dict() # noqa
        if is_enable(self.perspective): d["perspective"] = self.perspective.to_dict() # noqa
        if is_enable(self.type): d["type"] = self.type.to_dict() # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Camera':
        dst = {}
        if "orthographic" in src: dst["orthographic"] = CameraOrthographic.from_dict(src["orthographic"]) # noqa
        if "perspective" in src: dst["perspective"] = CameraPerspective.from_dict(src["perspective"]) # noqa
        if "type" in src: dst["type"] = CameraType(src["type"]) # noqa
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Camera(**dst)


class ImageMimeType(Enum):
    ImageJpeg = "image/jpeg"
    ImagePng = "image/png"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'ImageMimeType':
        dst = {}
        return ImageMimeType(dst)


class Image(NamedTuple):
    # The uri of the image.
    uri: Optional[str] = None
    # The image's MIME type. Required if `bufferView` is defined.
    mimeType: Optional[ImageMimeType] = None
    # The index of the bufferView that contains the image. Use this instead of the image's uri property.
    bufferView: Optional[int] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.uri): d["uri"] = self.uri # noqa
        if is_enable(self.mimeType): d["mimeType"] = self.mimeType.to_dict() # noqa
        if is_enable(self.bufferView): d["bufferView"] = self.bufferView # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Image':
        dst = {}
        if "uri" in src: dst["uri"] = src["uri"] # noqa copy
        if "mimeType" in src: dst["mimeType"] = ImageMimeType(src["mimeType"]) # noqa
        if "bufferView" in src: dst["bufferView"] = src["bufferView"] # noqa copy
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Image(**dst)


class KHR_materials_unlitGlTFExtension(NamedTuple):
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'KHR_materials_unlitGlTFExtension':
        dst = {}
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return KHR_materials_unlitGlTFExtension(**dst)


class materialsItemExtension(NamedTuple):
    # glTF extension that defines the unlit material model.
    KHR_materials_unlit: Optional[KHR_materials_unlitGlTFExtension] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.KHR_materials_unlit): d["KHR_materials_unlit"] = self.KHR_materials_unlit.to_dict() # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'materialsItemExtension':
        dst = {}
        if "KHR_materials_unlit" in src: dst["KHR_materials_unlit"] = KHR_materials_unlitGlTFExtension.from_dict(src["KHR_materials_unlit"]) # noqa
        return materialsItemExtension(**dst)


class TextureInfo(NamedTuple):
    # The index of the texture.
    index: int
    # The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    texCoord: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.index): d["index"] = self.index # noqa
        if is_enable(self.texCoord): d["texCoord"] = self.texCoord # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'TextureInfo':
        dst = {}
        if "index" in src: dst["index"] = src["index"] # noqa copy
        if "texCoord" in src: dst["texCoord"] = src["texCoord"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return TextureInfo(**dst)


class MaterialPBRMetallicRoughness(NamedTuple):
    # The material's base color factor.
    baseColorFactor: Optional[List[float]] = None
    # Reference to a texture.
    baseColorTexture: Optional[TextureInfo] = None
    # The metalness of the material.
    metallicFactor: Optional[float] = None
    # The roughness of the material.
    roughnessFactor: Optional[float] = None
    # Reference to a texture.
    metallicRoughnessTexture: Optional[TextureInfo] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.baseColorFactor: d["baseColorFactor"] = self.baseColorFactor # noqa
        if is_enable(self.baseColorTexture): d["baseColorTexture"] = self.baseColorTexture.to_dict() # noqa
        if is_enable(self.metallicFactor): d["metallicFactor"] = self.metallicFactor # noqa
        if is_enable(self.roughnessFactor): d["roughnessFactor"] = self.roughnessFactor # noqa
        if is_enable(self.metallicRoughnessTexture): d["metallicRoughnessTexture"] = self.metallicRoughnessTexture.to_dict() # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MaterialPBRMetallicRoughness':
        dst = {}
        dst["baseColorFactor"] = src.get("baseColorFactor", [])
        if "baseColorTexture" in src: dst["baseColorTexture"] = TextureInfo.from_dict(src["baseColorTexture"]) # noqa
        if "metallicFactor" in src: dst["metallicFactor"] = src["metallicFactor"] # noqa copy
        if "roughnessFactor" in src: dst["roughnessFactor"] = src["roughnessFactor"] # noqa copy
        if "metallicRoughnessTexture" in src: dst["metallicRoughnessTexture"] = TextureInfo.from_dict(src["metallicRoughnessTexture"]) # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return MaterialPBRMetallicRoughness(**dst)


class MaterialNormalTextureInfo(NamedTuple):
    # The index of the texture.
    index: int
    # The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    texCoord: Optional[int] = None
    # The scalar multiplier applied to each normal vector of the normal texture.
    scale: Optional[float] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.index): d["index"] = self.index # noqa
        if is_enable(self.texCoord): d["texCoord"] = self.texCoord # noqa
        if is_enable(self.scale): d["scale"] = self.scale # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MaterialNormalTextureInfo':
        dst = {}
        if "index" in src: dst["index"] = src["index"] # noqa copy
        if "texCoord" in src: dst["texCoord"] = src["texCoord"] # noqa copy
        if "scale" in src: dst["scale"] = src["scale"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return MaterialNormalTextureInfo(**dst)


class MaterialOcclusionTextureInfo(NamedTuple):
    # The index of the texture.
    index: int
    # The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    texCoord: Optional[int] = None
    # A scalar multiplier controlling the amount of occlusion applied.
    strength: Optional[float] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.index): d["index"] = self.index # noqa
        if is_enable(self.texCoord): d["texCoord"] = self.texCoord # noqa
        if is_enable(self.strength): d["strength"] = self.strength # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MaterialOcclusionTextureInfo':
        dst = {}
        if "index" in src: dst["index"] = src["index"] # noqa copy
        if "texCoord" in src: dst["texCoord"] = src["texCoord"] # noqa copy
        if "strength" in src: dst["strength"] = src["strength"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return MaterialOcclusionTextureInfo(**dst)


class MaterialAlphaMode(Enum):
    OPAQUE = "OPAQUE"
    MASK = "MASK"
    BLEND = "BLEND"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'MaterialAlphaMode':
        dst = {}
        return MaterialAlphaMode(dst)


class Material(NamedTuple):
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[materialsItemExtension] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None
    # A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology.
    pbrMetallicRoughness: Optional[MaterialPBRMetallicRoughness] = None
    # Reference to a texture.
    normalTexture: Optional[MaterialNormalTextureInfo] = None
    # Reference to a texture.
    occlusionTexture: Optional[MaterialOcclusionTextureInfo] = None
    # Reference to a texture.
    emissiveTexture: Optional[TextureInfo] = None
    # The emissive color of the material.
    emissiveFactor: Optional[List[float]] = None
    # The alpha rendering mode of the material.
    alphaMode: Optional[MaterialAlphaMode] = None
    # The alpha cutoff value of the material.
    alphaCutoff: Optional[float] = None
    # Specifies whether the material is double sided.
    doubleSided: Optional[bool] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions.to_dict() # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        if is_enable(self.pbrMetallicRoughness): d["pbrMetallicRoughness"] = self.pbrMetallicRoughness.to_dict() # noqa
        if is_enable(self.normalTexture): d["normalTexture"] = self.normalTexture.to_dict() # noqa
        if is_enable(self.occlusionTexture): d["occlusionTexture"] = self.occlusionTexture.to_dict() # noqa
        if is_enable(self.emissiveTexture): d["emissiveTexture"] = self.emissiveTexture.to_dict() # noqa
        if self.emissiveFactor: d["emissiveFactor"] = self.emissiveFactor # noqa
        if is_enable(self.alphaMode): d["alphaMode"] = self.alphaMode.to_dict() # noqa
        if is_enable(self.alphaCutoff): d["alphaCutoff"] = self.alphaCutoff # noqa
        if is_enable(self.doubleSided): d["doubleSided"] = self.doubleSided # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Material':
        dst = {}
        if "name" in src: dst["name"] = src["name"] # noqa copy
        if "extensions" in src: dst["extensions"] = materialsItemExtension.from_dict(src["extensions"]) # noqa
        dst["extras"] = src.get("extras", {})
        if "pbrMetallicRoughness" in src: dst["pbrMetallicRoughness"] = MaterialPBRMetallicRoughness.from_dict(src["pbrMetallicRoughness"]) # noqa
        if "normalTexture" in src: dst["normalTexture"] = MaterialNormalTextureInfo.from_dict(src["normalTexture"]) # noqa
        if "occlusionTexture" in src: dst["occlusionTexture"] = MaterialOcclusionTextureInfo.from_dict(src["occlusionTexture"]) # noqa
        if "emissiveTexture" in src: dst["emissiveTexture"] = TextureInfo.from_dict(src["emissiveTexture"]) # noqa
        dst["emissiveFactor"] = src.get("emissiveFactor", [])
        if "alphaMode" in src: dst["alphaMode"] = MaterialAlphaMode(src["alphaMode"]) # noqa
        if "alphaCutoff" in src: dst["alphaCutoff"] = src["alphaCutoff"] # noqa copy
        if "doubleSided" in src: dst["doubleSided"] = src["doubleSided"] # noqa copy
        return Material(**dst)


class MeshPrimitiveMode(Enum):
    POINTS = 0
    LINES = 1
    LINE_LOOP = 2
    LINE_STRIP = 3
    TRIANGLES = 4
    TRIANGLE_STRIP = 5
    TRIANGLE_FAN = 6

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'MeshPrimitiveMode':
        dst = {}
        return MeshPrimitiveMode(dst)


class meshesItemPrimitivesItemExtras(NamedTuple):
    # 
    targetNames: Optional[List[Dict[str, Any]]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.targetNames: d["targetNames"] = self.targetNames # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'meshesItemPrimitivesItemExtras':
        dst = {}
        dst["targetNames"] = src.get("targetNames", [])
        return meshesItemPrimitivesItemExtras(**dst)


class MeshPrimitive(NamedTuple):
    # A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data.
    attributes: Dict[str, int]
    # The index of the accessor that contains the indices.
    indices: Optional[int] = None
    # The index of the material to apply to this primitive when rendering.
    material: Optional[int] = None
    # The type of primitives to render.
    mode: Optional[MeshPrimitiveMode] = None
    # An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their deviations in the Morph Target.
    targets: Optional[List[Dict[str, int]]] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[meshesItemPrimitivesItemExtras] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.attributes): d["attributes"] = self.attributes # noqa
        if is_enable(self.indices): d["indices"] = self.indices # noqa
        if is_enable(self.material): d["material"] = self.material # noqa
        if is_enable(self.mode): d["mode"] = self.mode.to_dict() # noqa
        if self.targets: d["targets"] = self.targets # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras.to_dict() # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MeshPrimitive':
        dst = {}
        dst["attributes"] = src.get("attributes", {})
        if "indices" in src: dst["indices"] = src["indices"] # noqa copy
        if "material" in src: dst["material"] = src["material"] # noqa copy
        if "mode" in src: dst["mode"] = MeshPrimitiveMode(src["mode"]) # noqa
        dst["targets"] = src.get("targets", [])
        dst["extensions"] = src.get("extensions", {})
        if "extras" in src: dst["extras"] = meshesItemPrimitivesItemExtras.from_dict(src["extras"]) # noqa
        return MeshPrimitive(**dst)


class meshesItemExtras(NamedTuple):
    # 
    targetNames: Optional[List[Dict[str, Any]]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.targetNames: d["targetNames"] = self.targetNames # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'meshesItemExtras':
        dst = {}
        dst["targetNames"] = src.get("targetNames", [])
        return meshesItemExtras(**dst)


class Mesh(NamedTuple):
    # An array of primitives, each defining geometry to be rendered with a material.
    primitives: List[MeshPrimitive]
    # Array of weights to be applied to the Morph Targets.
    weights: Optional[List[float]] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[meshesItemExtras] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.primitives: d["primitives"] = [item.to_dict() for item in self.primitives] # noqa
        if self.weights: d["weights"] = self.weights # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras.to_dict() # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Mesh':
        dst = {}
        dst["primitives"] = [MeshPrimitive.from_dict(item) for item in src["primitives"]] if "primitives" in src else [] # noqa
        dst["weights"] = src.get("weights", [])
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        if "extras" in src: dst["extras"] = meshesItemExtras.from_dict(src["extras"]) # noqa
        return Mesh(**dst)


class Node(NamedTuple):
    # The index of the camera referenced by this node.
    camera: Optional[int] = None
    # The indices of this node's children.
    children: Optional[List[int]] = None
    # The index of the skin referenced by this node.
    skin: Optional[int] = None
    # A floating-point 4x4 transformation matrix stored in column-major order.
    matrix: Optional[List[float]] = None
    # The index of the mesh in this node.
    mesh: Optional[int] = None
    # The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.
    rotation: Optional[List[float]] = None
    # The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.
    scale: Optional[List[float]] = None
    # The node's translation along the x, y, and z axes.
    translation: Optional[List[float]] = None
    # The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh.
    weights: Optional[List[float]] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.camera): d["camera"] = self.camera # noqa
        if self.children: d["children"] = self.children # noqa
        if is_enable(self.skin): d["skin"] = self.skin # noqa
        if self.matrix: d["matrix"] = self.matrix # noqa
        if is_enable(self.mesh): d["mesh"] = self.mesh # noqa
        if self.rotation: d["rotation"] = self.rotation # noqa
        if self.scale: d["scale"] = self.scale # noqa
        if self.translation: d["translation"] = self.translation # noqa
        if self.weights: d["weights"] = self.weights # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Node':
        dst = {}
        if "camera" in src: dst["camera"] = src["camera"] # noqa copy
        dst["children"] = src.get("children", [])
        if "skin" in src: dst["skin"] = src["skin"] # noqa copy
        dst["matrix"] = src.get("matrix", [])
        if "mesh" in src: dst["mesh"] = src["mesh"] # noqa copy
        dst["rotation"] = src.get("rotation", [])
        dst["scale"] = src.get("scale", [])
        dst["translation"] = src.get("translation", [])
        dst["weights"] = src.get("weights", [])
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Node(**dst)


class SamplerMagFilter(Enum):
    NEAREST = 9728
    LINEAR = 9729

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerMagFilter':
        dst = {}
        return SamplerMagFilter(dst)


class SamplerMinFilter(Enum):
    NEAREST = 9728
    LINEAR = 9729
    NEAREST_MIPMAP_NEAREST = 9984
    LINEAR_MIPMAP_NEAREST = 9985
    NEAREST_MIPMAP_LINEAR = 9986
    LINEAR_MIPMAP_LINEAR = 9987

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerMinFilter':
        dst = {}
        return SamplerMinFilter(dst)


class SamplerWrapS(Enum):
    CLAMP_TO_EDGE = 33071
    MIRRORED_REPEAT = 33648
    REPEAT = 10497

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerWrapS':
        dst = {}
        return SamplerWrapS(dst)


class SamplerWrapT(Enum):
    CLAMP_TO_EDGE = 33071
    MIRRORED_REPEAT = 33648
    REPEAT = 10497

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerWrapT':
        dst = {}
        return SamplerWrapT(dst)


class Sampler(NamedTuple):
    # Magnification filter.
    magFilter: Optional[SamplerMagFilter] = None
    # Minification filter.
    minFilter: Optional[SamplerMinFilter] = None
    # s wrapping mode.
    wrapS: Optional[SamplerWrapS] = None
    # t wrapping mode.
    wrapT: Optional[SamplerWrapT] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.magFilter): d["magFilter"] = self.magFilter.to_dict() # noqa
        if is_enable(self.minFilter): d["minFilter"] = self.minFilter.to_dict() # noqa
        if is_enable(self.wrapS): d["wrapS"] = self.wrapS.to_dict() # noqa
        if is_enable(self.wrapT): d["wrapT"] = self.wrapT.to_dict() # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Sampler':
        dst = {}
        if "magFilter" in src: dst["magFilter"] = SamplerMagFilter(src["magFilter"]) # noqa
        if "minFilter" in src: dst["minFilter"] = SamplerMinFilter(src["minFilter"]) # noqa
        if "wrapS" in src: dst["wrapS"] = SamplerWrapS(src["wrapS"]) # noqa
        if "wrapT" in src: dst["wrapT"] = SamplerWrapT(src["wrapT"]) # noqa
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Sampler(**dst)


class Scene(NamedTuple):
    # The indices of each root node.
    nodes: Optional[List[int]] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.nodes: d["nodes"] = self.nodes # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Scene':
        dst = {}
        dst["nodes"] = src.get("nodes", [])
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Scene(**dst)


class Skin(NamedTuple):
    # Indices of skeleton nodes, used as joints in this skin.
    joints: List[int]
    # The index of the accessor containing the floating-point 4x4 inverse-bind matrices.  The default is that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were pre-applied.
    inverseBindMatrices: Optional[int] = None
    # The index of the node used as a skeleton root.
    skeleton: Optional[int] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.inverseBindMatrices): d["inverseBindMatrices"] = self.inverseBindMatrices # noqa
        if is_enable(self.skeleton): d["skeleton"] = self.skeleton # noqa
        if self.joints: d["joints"] = self.joints # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Skin':
        dst = {}
        if "inverseBindMatrices" in src: dst["inverseBindMatrices"] = src["inverseBindMatrices"] # noqa copy
        if "skeleton" in src: dst["skeleton"] = src["skeleton"] # noqa copy
        dst["joints"] = src.get("joints", [])
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Skin(**dst)


class Texture(NamedTuple):
    # The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering should be used.
    sampler: Optional[int] = None
    # The index of the image used by this texture. When undefined, it is expected that an extension or other mechanism will supply an alternate texture source, otherwise behavior is undefined.
    source: Optional[int] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.sampler): d["sampler"] = self.sampler # noqa
        if is_enable(self.source): d["source"] = self.source # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Texture':
        dst = {}
        if "sampler" in src: dst["sampler"] = src["sampler"] # noqa copy
        if "source" in src: dst["source"] = src["source"] # noqa copy
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return Texture(**dst)


class vrmMeta(NamedTuple):
    # Title of VRM model
    title: Optional[str] = None
    # Version of VRM model
    version: Optional[str] = None
    # Author of VRM model
    author: Optional[str] = None
    # Contact Information of VRM model author
    contactInformation: Optional[str] = None
    # Reference of VRM model
    reference: Optional[str] = None
    # Thumbnail of VRM model
    texture: Optional[int] = None
    # A person who can perform with this avatar
    allowedUserName: Optional[str] = None
    # Permission to perform violent acts with this avatar
    violentUssageName: Optional[str] = None
    # Permission to perform sexual acts with this avatar
    sexualUssageName: Optional[str] = None
    # For commercial use
    commercialUssageName: Optional[str] = None
    # If there are any conditions not mentioned above, put the URL link of the license document here.
    otherPermissionUrl: Optional[str] = None
    # License type
    licenseName: Optional[str] = None
    # If Other is selected, put the URL link of the license document here.
    otherLicenseUrl: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.title): d["title"] = self.title # noqa
        if is_enable(self.version): d["version"] = self.version # noqa
        if is_enable(self.author): d["author"] = self.author # noqa
        if is_enable(self.contactInformation): d["contactInformation"] = self.contactInformation # noqa
        if is_enable(self.reference): d["reference"] = self.reference # noqa
        if is_enable(self.texture): d["texture"] = self.texture # noqa
        if is_enable(self.allowedUserName): d["allowedUserName"] = self.allowedUserName # noqa
        if is_enable(self.violentUssageName): d["violentUssageName"] = self.violentUssageName # noqa
        if is_enable(self.sexualUssageName): d["sexualUssageName"] = self.sexualUssageName # noqa
        if is_enable(self.commercialUssageName): d["commercialUssageName"] = self.commercialUssageName # noqa
        if is_enable(self.otherPermissionUrl): d["otherPermissionUrl"] = self.otherPermissionUrl # noqa
        if is_enable(self.licenseName): d["licenseName"] = self.licenseName # noqa
        if is_enable(self.otherLicenseUrl): d["otherLicenseUrl"] = self.otherLicenseUrl # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmMeta':
        dst = {}
        if "title" in src: dst["title"] = src["title"] # noqa copy
        if "version" in src: dst["version"] = src["version"] # noqa copy
        if "author" in src: dst["author"] = src["author"] # noqa copy
        if "contactInformation" in src: dst["contactInformation"] = src["contactInformation"] # noqa copy
        if "reference" in src: dst["reference"] = src["reference"] # noqa copy
        if "texture" in src: dst["texture"] = src["texture"] # noqa copy
        if "allowedUserName" in src: dst["allowedUserName"] = src["allowedUserName"] # noqa copy
        if "violentUssageName" in src: dst["violentUssageName"] = src["violentUssageName"] # noqa copy
        if "sexualUssageName" in src: dst["sexualUssageName"] = src["sexualUssageName"] # noqa copy
        if "commercialUssageName" in src: dst["commercialUssageName"] = src["commercialUssageName"] # noqa copy
        if "otherPermissionUrl" in src: dst["otherPermissionUrl"] = src["otherPermissionUrl"] # noqa copy
        if "licenseName" in src: dst["licenseName"] = src["licenseName"] # noqa copy
        if "otherLicenseUrl" in src: dst["otherLicenseUrl"] = src["otherLicenseUrl"] # noqa copy
        return vrmMeta(**dst)


class humanoidHumanBonesItemMin(NamedTuple):
    # 
    x: Optional[float] = None
    # 
    y: Optional[float] = None
    # 
    z: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.x): d["x"] = self.x # noqa
        if is_enable(self.y): d["y"] = self.y # noqa
        if is_enable(self.z): d["z"] = self.z # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'humanoidHumanBonesItemMin':
        dst = {}
        if "x" in src: dst["x"] = src["x"] # noqa copy
        if "y" in src: dst["y"] = src["y"] # noqa copy
        if "z" in src: dst["z"] = src["z"] # noqa copy
        return humanoidHumanBonesItemMin(**dst)


class humanoidHumanBonesItemMax(NamedTuple):
    # 
    x: Optional[float] = None
    # 
    y: Optional[float] = None
    # 
    z: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.x): d["x"] = self.x # noqa
        if is_enable(self.y): d["y"] = self.y # noqa
        if is_enable(self.z): d["z"] = self.z # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'humanoidHumanBonesItemMax':
        dst = {}
        if "x" in src: dst["x"] = src["x"] # noqa copy
        if "y" in src: dst["y"] = src["y"] # noqa copy
        if "z" in src: dst["z"] = src["z"] # noqa copy
        return humanoidHumanBonesItemMax(**dst)


class humanoidHumanBonesItemCenter(NamedTuple):
    # 
    x: Optional[float] = None
    # 
    y: Optional[float] = None
    # 
    z: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.x): d["x"] = self.x # noqa
        if is_enable(self.y): d["y"] = self.y # noqa
        if is_enable(self.z): d["z"] = self.z # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'humanoidHumanBonesItemCenter':
        dst = {}
        if "x" in src: dst["x"] = src["x"] # noqa copy
        if "y" in src: dst["y"] = src["y"] # noqa copy
        if "z" in src: dst["z"] = src["z"] # noqa copy
        return humanoidHumanBonesItemCenter(**dst)


class vrmHumanoidBone(NamedTuple):
    # Human bone name.
    bone: Optional[str] = None
    # Reference node index
    node: Optional[int] = None
    # Unity's HumanLimit.useDefaultValues
    useDefaultValues: Optional[bool] = None
    # Unity's HumanLimit.min
    min: Optional[humanoidHumanBonesItemMin] = None
    # Unity's HumanLimit.max
    max: Optional[humanoidHumanBonesItemMax] = None
    # Unity's HumanLimit.center
    center: Optional[humanoidHumanBonesItemCenter] = None
    # Unity's HumanLimit.axisLength
    axisLength: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.bone): d["bone"] = self.bone # noqa
        if is_enable(self.node): d["node"] = self.node # noqa
        if is_enable(self.useDefaultValues): d["useDefaultValues"] = self.useDefaultValues # noqa
        if is_enable(self.min): d["min"] = self.min.to_dict() # noqa
        if is_enable(self.max): d["max"] = self.max.to_dict() # noqa
        if is_enable(self.center): d["center"] = self.center.to_dict() # noqa
        if is_enable(self.axisLength): d["axisLength"] = self.axisLength # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmHumanoidBone':
        dst = {}
        if "bone" in src: dst["bone"] = src["bone"] # noqa copy
        if "node" in src: dst["node"] = src["node"] # noqa copy
        if "useDefaultValues" in src: dst["useDefaultValues"] = src["useDefaultValues"] # noqa copy
        if "min" in src: dst["min"] = humanoidHumanBonesItemMin.from_dict(src["min"]) # noqa
        if "max" in src: dst["max"] = humanoidHumanBonesItemMax.from_dict(src["max"]) # noqa
        if "center" in src: dst["center"] = humanoidHumanBonesItemCenter.from_dict(src["center"]) # noqa
        if "axisLength" in src: dst["axisLength"] = src["axisLength"] # noqa copy
        return vrmHumanoidBone(**dst)


class vrmHumanoid(NamedTuple):
    # 
    humanBones: Optional[List[vrmHumanoidBone]] = None
    # Unity's HumanDescription.armStretch
    armStretch: Optional[float] = None
    # Unity's HumanDescription.legStretch
    legStretch: Optional[float] = None
    # Unity's HumanDescription.upperArmTwist
    upperArmTwist: Optional[float] = None
    # Unity's HumanDescription.lowerArmTwist
    lowerArmTwist: Optional[float] = None
    # Unity's HumanDescription.upperLegTwist
    upperLegTwist: Optional[float] = None
    # Unity's HumanDescription.lowerLegTwist
    lowerLegTwist: Optional[float] = None
    # Unity's HumanDescription.feetSpacing
    feetSpacing: Optional[float] = None
    # Unity's HumanDescription.hasTranslationDoF
    hasTranslationDoF: Optional[bool] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.humanBones: d["humanBones"] = [item.to_dict() for item in self.humanBones] # noqa
        if is_enable(self.armStretch): d["armStretch"] = self.armStretch # noqa
        if is_enable(self.legStretch): d["legStretch"] = self.legStretch # noqa
        if is_enable(self.upperArmTwist): d["upperArmTwist"] = self.upperArmTwist # noqa
        if is_enable(self.lowerArmTwist): d["lowerArmTwist"] = self.lowerArmTwist # noqa
        if is_enable(self.upperLegTwist): d["upperLegTwist"] = self.upperLegTwist # noqa
        if is_enable(self.lowerLegTwist): d["lowerLegTwist"] = self.lowerLegTwist # noqa
        if is_enable(self.feetSpacing): d["feetSpacing"] = self.feetSpacing # noqa
        if is_enable(self.hasTranslationDoF): d["hasTranslationDoF"] = self.hasTranslationDoF # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmHumanoid':
        dst = {}
        dst["humanBones"] = [vrmHumanoidBone.from_dict(item) for item in src["humanBones"]] if "humanBones" in src else [] # noqa
        if "armStretch" in src: dst["armStretch"] = src["armStretch"] # noqa copy
        if "legStretch" in src: dst["legStretch"] = src["legStretch"] # noqa copy
        if "upperArmTwist" in src: dst["upperArmTwist"] = src["upperArmTwist"] # noqa copy
        if "lowerArmTwist" in src: dst["lowerArmTwist"] = src["lowerArmTwist"] # noqa copy
        if "upperLegTwist" in src: dst["upperLegTwist"] = src["upperLegTwist"] # noqa copy
        if "lowerLegTwist" in src: dst["lowerLegTwist"] = src["lowerLegTwist"] # noqa copy
        if "feetSpacing" in src: dst["feetSpacing"] = src["feetSpacing"] # noqa copy
        if "hasTranslationDoF" in src: dst["hasTranslationDoF"] = src["hasTranslationDoF"] # noqa copy
        return vrmHumanoid(**dst)


class firstPersonFirstPersonBoneOffset(NamedTuple):
    # 
    x: Optional[float] = None
    # 
    y: Optional[float] = None
    # 
    z: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.x): d["x"] = self.x # noqa
        if is_enable(self.y): d["y"] = self.y # noqa
        if is_enable(self.z): d["z"] = self.z # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'firstPersonFirstPersonBoneOffset':
        dst = {}
        if "x" in src: dst["x"] = src["x"] # noqa copy
        if "y" in src: dst["y"] = src["y"] # noqa copy
        if "z" in src: dst["z"] = src["z"] # noqa copy
        return firstPersonFirstPersonBoneOffset(**dst)


class vrmFirstpersonMeshannotation(NamedTuple):
    # 
    mesh: Optional[int] = None
    # 
    firstPersonFlag: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.mesh): d["mesh"] = self.mesh # noqa
        if is_enable(self.firstPersonFlag): d["firstPersonFlag"] = self.firstPersonFlag # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmFirstpersonMeshannotation':
        dst = {}
        if "mesh" in src: dst["mesh"] = src["mesh"] # noqa copy
        if "firstPersonFlag" in src: dst["firstPersonFlag"] = src["firstPersonFlag"] # noqa copy
        return vrmFirstpersonMeshannotation(**dst)


class vrmFirstpersonDegreemap(NamedTuple):
    # None linear mapping params. time, value, inTangent, outTangent
    curve: Optional[List[float]] = None
    # Look at input clamp range degree.
    xRange: Optional[float] = None
    # Look at map range degree from xRange.
    yRange: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.curve: d["curve"] = self.curve # noqa
        if is_enable(self.xRange): d["xRange"] = self.xRange # noqa
        if is_enable(self.yRange): d["yRange"] = self.yRange # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmFirstpersonDegreemap':
        dst = {}
        dst["curve"] = src.get("curve", [])
        if "xRange" in src: dst["xRange"] = src["xRange"] # noqa copy
        if "yRange" in src: dst["yRange"] = src["yRange"] # noqa copy
        return vrmFirstpersonDegreemap(**dst)


class vrmFirstperson(NamedTuple):
    # The bone whose rendering should be turned off in first-person view. Usually Head is specified.
    firstPersonBone: Optional[int] = None
    # The target position of the VR headset in first-person view. It is assumed that an offset from the head bone to the VR headset is added.
    firstPersonBoneOffset: Optional[firstPersonFirstPersonBoneOffset] = None
    # Switch display / undisplay for each mesh in first-person view or the others.
    meshAnnotations: Optional[List[vrmFirstpersonMeshannotation]] = None
    # Eye controller mode.
    lookAtTypeName: Optional[str] = None
    # Eye controller setting.
    lookAtHorizontalInner: Optional[vrmFirstpersonDegreemap] = None
    # Eye controller setting.
    lookAtHorizontalOuter: Optional[vrmFirstpersonDegreemap] = None
    # Eye controller setting.
    lookAtVerticalDown: Optional[vrmFirstpersonDegreemap] = None
    # Eye controller setting.
    lookAtVerticalUp: Optional[vrmFirstpersonDegreemap] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.firstPersonBone): d["firstPersonBone"] = self.firstPersonBone # noqa
        if is_enable(self.firstPersonBoneOffset): d["firstPersonBoneOffset"] = self.firstPersonBoneOffset.to_dict() # noqa
        if self.meshAnnotations: d["meshAnnotations"] = [item.to_dict() for item in self.meshAnnotations] # noqa
        if is_enable(self.lookAtTypeName): d["lookAtTypeName"] = self.lookAtTypeName # noqa
        if is_enable(self.lookAtHorizontalInner): d["lookAtHorizontalInner"] = self.lookAtHorizontalInner.to_dict() # noqa
        if is_enable(self.lookAtHorizontalOuter): d["lookAtHorizontalOuter"] = self.lookAtHorizontalOuter.to_dict() # noqa
        if is_enable(self.lookAtVerticalDown): d["lookAtVerticalDown"] = self.lookAtVerticalDown.to_dict() # noqa
        if is_enable(self.lookAtVerticalUp): d["lookAtVerticalUp"] = self.lookAtVerticalUp.to_dict() # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmFirstperson':
        dst = {}
        if "firstPersonBone" in src: dst["firstPersonBone"] = src["firstPersonBone"] # noqa copy
        if "firstPersonBoneOffset" in src: dst["firstPersonBoneOffset"] = firstPersonFirstPersonBoneOffset.from_dict(src["firstPersonBoneOffset"]) # noqa
        dst["meshAnnotations"] = [vrmFirstpersonMeshannotation.from_dict(item) for item in src["meshAnnotations"]] if "meshAnnotations" in src else [] # noqa
        if "lookAtTypeName" in src: dst["lookAtTypeName"] = src["lookAtTypeName"] # noqa copy
        if "lookAtHorizontalInner" in src: dst["lookAtHorizontalInner"] = vrmFirstpersonDegreemap.from_dict(src["lookAtHorizontalInner"]) # noqa
        if "lookAtHorizontalOuter" in src: dst["lookAtHorizontalOuter"] = vrmFirstpersonDegreemap.from_dict(src["lookAtHorizontalOuter"]) # noqa
        if "lookAtVerticalDown" in src: dst["lookAtVerticalDown"] = vrmFirstpersonDegreemap.from_dict(src["lookAtVerticalDown"]) # noqa
        if "lookAtVerticalUp" in src: dst["lookAtVerticalUp"] = vrmFirstpersonDegreemap.from_dict(src["lookAtVerticalUp"]) # noqa
        return vrmFirstperson(**dst)


class vrmBlendshapeBind(NamedTuple):
    # 
    mesh: Optional[int] = None
    # 
    index: Optional[int] = None
    # SkinnedMeshRenderer.SetBlendShapeWeight
    weight: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.mesh): d["mesh"] = self.mesh # noqa
        if is_enable(self.index): d["index"] = self.index # noqa
        if is_enable(self.weight): d["weight"] = self.weight # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmBlendshapeBind':
        dst = {}
        if "mesh" in src: dst["mesh"] = src["mesh"] # noqa copy
        if "index" in src: dst["index"] = src["index"] # noqa copy
        if "weight" in src: dst["weight"] = src["weight"] # noqa copy
        return vrmBlendshapeBind(**dst)


class vrmBlendshapeMaterialbind(NamedTuple):
    # 
    materialName: Optional[str] = None
    # 
    propertyName: Optional[str] = None
    # 
    targetValue: Optional[List[float]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.materialName): d["materialName"] = self.materialName # noqa
        if is_enable(self.propertyName): d["propertyName"] = self.propertyName # noqa
        if self.targetValue: d["targetValue"] = self.targetValue # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmBlendshapeMaterialbind':
        dst = {}
        if "materialName" in src: dst["materialName"] = src["materialName"] # noqa copy
        if "propertyName" in src: dst["propertyName"] = src["propertyName"] # noqa copy
        dst["targetValue"] = src.get("targetValue", [])
        return vrmBlendshapeMaterialbind(**dst)


class vrmBlendshapeGroup(NamedTuple):
    # Expression name
    name: Optional[str] = None
    # Predefined Expression name
    presetName: Optional[str] = None
    # Low level blendshape references.
    binds: Optional[List[vrmBlendshapeBind]] = None
    # Material animation references.
    materialValues: Optional[List[vrmBlendshapeMaterialbind]] = None
    # 0 or 1. Do not allow an intermediate value. Value should rounded
    isBinary: Optional[bool] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.presetName): d["presetName"] = self.presetName # noqa
        if self.binds: d["binds"] = [item.to_dict() for item in self.binds] # noqa
        if self.materialValues: d["materialValues"] = [item.to_dict() for item in self.materialValues] # noqa
        if is_enable(self.isBinary): d["isBinary"] = self.isBinary # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmBlendshapeGroup':
        dst = {}
        if "name" in src: dst["name"] = src["name"] # noqa copy
        if "presetName" in src: dst["presetName"] = src["presetName"] # noqa copy
        dst["binds"] = [vrmBlendshapeBind.from_dict(item) for item in src["binds"]] if "binds" in src else [] # noqa
        dst["materialValues"] = [vrmBlendshapeMaterialbind.from_dict(item) for item in src["materialValues"]] if "materialValues" in src else [] # noqa
        if "isBinary" in src: dst["isBinary"] = src["isBinary"] # noqa copy
        return vrmBlendshapeGroup(**dst)


class vrmBlendshape(NamedTuple):
    # 
    blendShapeGroups: Optional[List[vrmBlendshapeGroup]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.blendShapeGroups: d["blendShapeGroups"] = [item.to_dict() for item in self.blendShapeGroups] # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmBlendshape':
        dst = {}
        dst["blendShapeGroups"] = [vrmBlendshapeGroup.from_dict(item) for item in src["blendShapeGroups"]] if "blendShapeGroups" in src else [] # noqa
        return vrmBlendshape(**dst)


class secondaryAnimationBoneGroupsItemGravityDir(NamedTuple):
    # 
    x: Optional[float] = None
    # 
    y: Optional[float] = None
    # 
    z: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.x): d["x"] = self.x # noqa
        if is_enable(self.y): d["y"] = self.y # noqa
        if is_enable(self.z): d["z"] = self.z # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'secondaryAnimationBoneGroupsItemGravityDir':
        dst = {}
        if "x" in src: dst["x"] = src["x"] # noqa copy
        if "y" in src: dst["y"] = src["y"] # noqa copy
        if "z" in src: dst["z"] = src["z"] # noqa copy
        return secondaryAnimationBoneGroupsItemGravityDir(**dst)


class vrmSecondaryanimationSpring(NamedTuple):
    # Annotation comment
    comment: Optional[str] = None
    # The resilience of the swaying object (the power of returning to the initial pose).
    stiffiness: Optional[float] = None
    # The strength of gravity.
    gravityPower: Optional[float] = None
    # The direction of gravity. Set (0, -1, 0) for simulating the gravity. Set (1, 0, 0) for simulating the wind.
    gravityDir: Optional[secondaryAnimationBoneGroupsItemGravityDir] = None
    # The resistance (deceleration) of automatic animation.
    dragForce: Optional[float] = None
    # The reference point of a swaying object can be set at any location except the origin. When implementing UI moving with warp, the parent node to move with warp can be specified if you don't want to make the object swaying with warp movement.
    center: Optional[int] = None
    # The radius of the sphere used for the collision detection with colliders.
    hitRadius: Optional[float] = None
    # Specify the node index of the root bone of the swaying object.
    bones: Optional[List[int]] = None
    # Specify the index of the collider group for collisions with swaying objects.
    colliderGroups: Optional[List[int]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.comment): d["comment"] = self.comment # noqa
        if is_enable(self.stiffiness): d["stiffiness"] = self.stiffiness # noqa
        if is_enable(self.gravityPower): d["gravityPower"] = self.gravityPower # noqa
        if is_enable(self.gravityDir): d["gravityDir"] = self.gravityDir.to_dict() # noqa
        if is_enable(self.dragForce): d["dragForce"] = self.dragForce # noqa
        if is_enable(self.center): d["center"] = self.center # noqa
        if is_enable(self.hitRadius): d["hitRadius"] = self.hitRadius # noqa
        if self.bones: d["bones"] = self.bones # noqa
        if self.colliderGroups: d["colliderGroups"] = self.colliderGroups # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmSecondaryanimationSpring':
        dst = {}
        if "comment" in src: dst["comment"] = src["comment"] # noqa copy
        if "stiffiness" in src: dst["stiffiness"] = src["stiffiness"] # noqa copy
        if "gravityPower" in src: dst["gravityPower"] = src["gravityPower"] # noqa copy
        if "gravityDir" in src: dst["gravityDir"] = secondaryAnimationBoneGroupsItemGravityDir.from_dict(src["gravityDir"]) # noqa
        if "dragForce" in src: dst["dragForce"] = src["dragForce"] # noqa copy
        if "center" in src: dst["center"] = src["center"] # noqa copy
        if "hitRadius" in src: dst["hitRadius"] = src["hitRadius"] # noqa copy
        dst["bones"] = src.get("bones", [])
        dst["colliderGroups"] = src.get("colliderGroups", [])
        return vrmSecondaryanimationSpring(**dst)


class secondaryAnimationColliderGroupsItemCollidersItemOffset(NamedTuple):
    # 
    x: Optional[float] = None
    # 
    y: Optional[float] = None
    # 
    z: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.x): d["x"] = self.x # noqa
        if is_enable(self.y): d["y"] = self.y # noqa
        if is_enable(self.z): d["z"] = self.z # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'secondaryAnimationColliderGroupsItemCollidersItemOffset':
        dst = {}
        if "x" in src: dst["x"] = src["x"] # noqa copy
        if "y" in src: dst["y"] = src["y"] # noqa copy
        if "z" in src: dst["z"] = src["z"] # noqa copy
        return secondaryAnimationColliderGroupsItemCollidersItemOffset(**dst)


class secondaryAnimationColliderGroupsItemCollidersItem(NamedTuple):
    # The local coordinate from the node of the collider group in *left-handed* Y-up coordinate.
    offset: Optional[secondaryAnimationColliderGroupsItemCollidersItemOffset] = None
    # The radius of the collider.
    radius: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.offset): d["offset"] = self.offset.to_dict() # noqa
        if is_enable(self.radius): d["radius"] = self.radius # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'secondaryAnimationColliderGroupsItemCollidersItem':
        dst = {}
        if "offset" in src: dst["offset"] = secondaryAnimationColliderGroupsItemCollidersItemOffset.from_dict(src["offset"]) # noqa
        if "radius" in src: dst["radius"] = src["radius"] # noqa copy
        return secondaryAnimationColliderGroupsItemCollidersItem(**dst)


class vrmSecondaryanimationCollidergroup(NamedTuple):
    # The node of the collider group for setting up collision detections.
    node: Optional[int] = None
    # 
    colliders: Optional[List[secondaryAnimationColliderGroupsItemCollidersItem]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.node): d["node"] = self.node # noqa
        if self.colliders: d["colliders"] = [item.to_dict() for item in self.colliders] # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmSecondaryanimationCollidergroup':
        dst = {}
        if "node" in src: dst["node"] = src["node"] # noqa copy
        dst["colliders"] = [secondaryAnimationColliderGroupsItemCollidersItem.from_dict(item) for item in src["colliders"]] if "colliders" in src else [] # noqa
        return vrmSecondaryanimationCollidergroup(**dst)


class vrmSecondaryanimation(NamedTuple):
    # 
    boneGroups: Optional[List[vrmSecondaryanimationSpring]] = None
    # 
    colliderGroups: Optional[List[vrmSecondaryanimationCollidergroup]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.boneGroups: d["boneGroups"] = [item.to_dict() for item in self.boneGroups] # noqa
        if self.colliderGroups: d["colliderGroups"] = [item.to_dict() for item in self.colliderGroups] # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmSecondaryanimation':
        dst = {}
        dst["boneGroups"] = [vrmSecondaryanimationSpring.from_dict(item) for item in src["boneGroups"]] if "boneGroups" in src else [] # noqa
        dst["colliderGroups"] = [vrmSecondaryanimationCollidergroup.from_dict(item) for item in src["colliderGroups"]] if "colliderGroups" in src else [] # noqa
        return vrmSecondaryanimation(**dst)


class vrmMaterial(NamedTuple):
    # 
    name: Optional[str] = None
    # This contains shader name.  VRM/MToon, VRM/UnlitTransparentZWrite, and VRM_USE_GLTFSHADER (and legacy materials as Standard, UniGLTF/UniUnlit, VRM/UnlitTexture, VRM/UnlitCutout, VRM/UnlitTransparent) . If VRM_USE_GLTFSHADER is specified, use same index of gltf's material settings
    shader: Optional[str] = None
    # 
    renderQueue: Optional[int] = None
    # 
    floatProperties: Optional[Dict[str, float]] = None
    # 
    vectorProperties: Optional[Dict[str, List[float]]] = None
    # 
    textureProperties: Optional[Dict[str, int]] = None
    # 
    keywordMap: Optional[Dict[str, bool]] = None
    # 
    tagMap: Optional[Dict[str, str]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.shader): d["shader"] = self.shader # noqa
        if is_enable(self.renderQueue): d["renderQueue"] = self.renderQueue # noqa
        if is_enable(self.floatProperties): d["floatProperties"] = self.floatProperties # noqa
        if is_enable(self.vectorProperties): d["vectorProperties"] = self.vectorProperties # noqa
        if is_enable(self.textureProperties): d["textureProperties"] = self.textureProperties # noqa
        if is_enable(self.keywordMap): d["keywordMap"] = self.keywordMap # noqa
        if is_enable(self.tagMap): d["tagMap"] = self.tagMap # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrmMaterial':
        dst = {}
        if "name" in src: dst["name"] = src["name"] # noqa copy
        if "shader" in src: dst["shader"] = src["shader"] # noqa copy
        if "renderQueue" in src: dst["renderQueue"] = src["renderQueue"] # noqa copy
        dst["floatProperties"] = src.get("floatProperties", {})
        dst["vectorProperties"] = src.get("vectorProperties", {})
        dst["textureProperties"] = src.get("textureProperties", {})
        dst["keywordMap"] = src.get("keywordMap", {})
        dst["tagMap"] = src.get("tagMap", {})
        return vrmMaterial(**dst)


class vrm(NamedTuple):
    # Version of exporter that vrm created. UniVRM-0.46
    exporterVersion: Optional[str] = None
    # Version of VRM specification. 0.0
    specVersion: Optional[str] = None
    # 
    meta: Optional[vrmMeta] = None
    # 
    humanoid: Optional[vrmHumanoid] = None
    # 
    firstPerson: Optional[vrmFirstperson] = None
    # BlendShapeAvatar of UniVRM
    blendShapeMaster: Optional[vrmBlendshape] = None
    # The setting of automatic animation of string-like objects such as tails and hairs.
    secondaryAnimation: Optional[vrmSecondaryanimation] = None
    # 
    materialProperties: Optional[List[vrmMaterial]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.exporterVersion): d["exporterVersion"] = self.exporterVersion # noqa
        if is_enable(self.specVersion): d["specVersion"] = self.specVersion # noqa
        if is_enable(self.meta): d["meta"] = self.meta.to_dict() # noqa
        if is_enable(self.humanoid): d["humanoid"] = self.humanoid.to_dict() # noqa
        if is_enable(self.firstPerson): d["firstPerson"] = self.firstPerson.to_dict() # noqa
        if is_enable(self.blendShapeMaster): d["blendShapeMaster"] = self.blendShapeMaster.to_dict() # noqa
        if is_enable(self.secondaryAnimation): d["secondaryAnimation"] = self.secondaryAnimation.to_dict() # noqa
        if self.materialProperties: d["materialProperties"] = [item.to_dict() for item in self.materialProperties] # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'vrm':
        dst = {}
        if "exporterVersion" in src: dst["exporterVersion"] = src["exporterVersion"] # noqa copy
        if "specVersion" in src: dst["specVersion"] = src["specVersion"] # noqa copy
        if "meta" in src: dst["meta"] = vrmMeta.from_dict(src["meta"]) # noqa
        if "humanoid" in src: dst["humanoid"] = vrmHumanoid.from_dict(src["humanoid"]) # noqa
        if "firstPerson" in src: dst["firstPerson"] = vrmFirstperson.from_dict(src["firstPerson"]) # noqa
        if "blendShapeMaster" in src: dst["blendShapeMaster"] = vrmBlendshape.from_dict(src["blendShapeMaster"]) # noqa
        if "secondaryAnimation" in src: dst["secondaryAnimation"] = vrmSecondaryanimation.from_dict(src["secondaryAnimation"]) # noqa
        dst["materialProperties"] = [vrmMaterial.from_dict(item) for item in src["materialProperties"]] if "materialProperties" in src else [] # noqa
        return vrm(**dst)


class Extension(NamedTuple):
    # VRM extension is for 3d humanoid avatars (and models) in VR applications.
    VRM: Optional[vrm] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.VRM): d["VRM"] = self.VRM.to_dict() # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Extension':
        dst = {}
        if "VRM" in src: dst["VRM"] = vrm.from_dict(src["VRM"]) # noqa
        return Extension(**dst)


class glTF(NamedTuple):
    # Metadata about the glTF asset.
    asset: Asset
    # Names of glTF extensions used somewhere in this asset.
    extensionsUsed: Optional[List[str]] = None
    # Names of glTF extensions required to properly load this asset.
    extensionsRequired: Optional[List[str]] = None
    # An array of accessors.
    accessors: Optional[List[Accessor]] = None
    # An array of keyframe animations.
    animations: Optional[List[Animation]] = None
    # An array of buffers.
    buffers: Optional[List[Buffer]] = None
    # An array of bufferViews.
    bufferViews: Optional[List[BufferView]] = None
    # An array of cameras.
    cameras: Optional[List[Camera]] = None
    # An array of images.
    images: Optional[List[Image]] = None
    # An array of materials.
    materials: Optional[List[Material]] = None
    # An array of meshes.
    meshes: Optional[List[Mesh]] = None
    # An array of nodes.
    nodes: Optional[List[Node]] = None
    # An array of samplers.
    samplers: Optional[List[Sampler]] = None
    # The index of the default scene.
    scene: Optional[int] = None
    # An array of scenes.
    scenes: Optional[List[Scene]] = None
    # An array of skins.
    skins: Optional[List[Skin]] = None
    # An array of textures.
    textures: Optional[List[Texture]] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Extension] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.extensionsUsed: d["extensionsUsed"] = self.extensionsUsed # noqa
        if self.extensionsRequired: d["extensionsRequired"] = self.extensionsRequired # noqa
        if self.accessors: d["accessors"] = [item.to_dict() for item in self.accessors] # noqa
        if self.animations: d["animations"] = [item.to_dict() for item in self.animations] # noqa
        if is_enable(self.asset): d["asset"] = self.asset.to_dict() # noqa
        if self.buffers: d["buffers"] = [item.to_dict() for item in self.buffers] # noqa
        if self.bufferViews: d["bufferViews"] = [item.to_dict() for item in self.bufferViews] # noqa
        if self.cameras: d["cameras"] = [item.to_dict() for item in self.cameras] # noqa
        if self.images: d["images"] = [item.to_dict() for item in self.images] # noqa
        if self.materials: d["materials"] = [item.to_dict() for item in self.materials] # noqa
        if self.meshes: d["meshes"] = [item.to_dict() for item in self.meshes] # noqa
        if self.nodes: d["nodes"] = [item.to_dict() for item in self.nodes] # noqa
        if self.samplers: d["samplers"] = [item.to_dict() for item in self.samplers] # noqa
        if is_enable(self.scene): d["scene"] = self.scene # noqa
        if self.scenes: d["scenes"] = [item.to_dict() for item in self.scenes] # noqa
        if self.skins: d["skins"] = [item.to_dict() for item in self.skins] # noqa
        if self.textures: d["textures"] = [item.to_dict() for item in self.textures] # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions.to_dict() # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'glTF':
        dst = {}
        dst["extensionsUsed"] = src.get("extensionsUsed", [])
        dst["extensionsRequired"] = src.get("extensionsRequired", [])
        dst["accessors"] = [Accessor.from_dict(item) for item in src["accessors"]] if "accessors" in src else [] # noqa
        dst["animations"] = [Animation.from_dict(item) for item in src["animations"]] if "animations" in src else [] # noqa
        if "asset" in src: dst["asset"] = Asset.from_dict(src["asset"]) # noqa
        dst["buffers"] = [Buffer.from_dict(item) for item in src["buffers"]] if "buffers" in src else [] # noqa
        dst["bufferViews"] = [BufferView.from_dict(item) for item in src["bufferViews"]] if "bufferViews" in src else [] # noqa
        dst["cameras"] = [Camera.from_dict(item) for item in src["cameras"]] if "cameras" in src else [] # noqa
        dst["images"] = [Image.from_dict(item) for item in src["images"]] if "images" in src else [] # noqa
        dst["materials"] = [Material.from_dict(item) for item in src["materials"]] if "materials" in src else [] # noqa
        dst["meshes"] = [Mesh.from_dict(item) for item in src["meshes"]] if "meshes" in src else [] # noqa
        dst["nodes"] = [Node.from_dict(item) for item in src["nodes"]] if "nodes" in src else [] # noqa
        dst["samplers"] = [Sampler.from_dict(item) for item in src["samplers"]] if "samplers" in src else [] # noqa
        if "scene" in src: dst["scene"] = src["scene"] # noqa copy
        dst["scenes"] = [Scene.from_dict(item) for item in src["scenes"]] if "scenes" in src else [] # noqa
        dst["skins"] = [Skin.from_dict(item) for item in src["skins"]] if "skins" in src else [] # noqa
        dst["textures"] = [Texture.from_dict(item) for item in src["textures"]] if "textures" in src else [] # noqa
        if "extensions" in src: dst["extensions"] = Extension.from_dict(src["extensions"]) # noqa
        dst["extras"] = src.get("extras", {})
        return glTF(**dst)


if __name__ == '__main__':
    pass
