# this is generated by sukonbu
from typing import NamedTuple, List, Any, Optional, Dict
from enum import Enum


class AccessorComponentType(Enum):
    BYTE = 5120
    UNSIGNED_BYTE = 5121
    SHORT = 5122
    UNSIGNED_SHORT = 5123
    UNSIGNED_INT = 5125
    FLOAT = 5126

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AccessorComponentType':
        return AccessorComponentType(src)


class AccessorType(Enum):
    SCALAR = "SCALAR"
    VEC2 = "VEC2"
    VEC3 = "VEC3"
    VEC4 = "VEC4"
    MAT2 = "MAT2"
    MAT3 = "MAT3"
    MAT4 = "MAT4"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AccessorType':
        return AccessorType(src)


class AccessorSparseIndicesComponentType(Enum):
    UNSIGNED_BYTE = 5121
    UNSIGNED_SHORT = 5123
    UNSIGNED_INT = 5125

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AccessorSparseIndicesComponentType':
        return AccessorSparseIndicesComponentType(src)


class AccessorSparseIndices(NamedTuple):
    # The index of the bufferView.
    bufferView: int
    # The indices data type.
    componentType: AccessorSparseIndicesComponentType
    # The offset relative to the start of the bufferView in bytes. Must be aligned.
    byteOffset: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.bufferView is not None: d["bufferView"] = self.bufferView # noqa
        if self.byteOffset is not None: d["byteOffset"] = self.byteOffset # noqa
        if self.componentType is not None: d["componentType"] = self.componentType.to_dict() # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AccessorSparseIndices':
        # bufferView do nothing
        # byteOffset do nothing
        if "componentType" in src: src["componentType"] = AccessorSparseIndicesComponentType(src["componentType"]) # noqa
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return AccessorSparseIndices(**src)


class AccessorSparseValues(NamedTuple):
    # The index of the bufferView.
    bufferView: int
    # The offset relative to the start of the bufferView in bytes. Must be aligned.
    byteOffset: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.bufferView is not None: d["bufferView"] = self.bufferView # noqa
        if self.byteOffset is not None: d["byteOffset"] = self.byteOffset # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AccessorSparseValues':
        # bufferView do nothing
        # byteOffset do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return AccessorSparseValues(**src)


class AccessorSparse(NamedTuple):
    # Number of entries stored in the sparse array.
    count: int
    # Indices of those attributes that deviate from their initialization value.
    indices: AccessorSparseIndices
    # Array of size `accessor.sparse.count` times number of components storing the displaced accessor attributes pointed by `accessor.sparse.indices`.
    values: AccessorSparseValues
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.count is not None: d["count"] = self.count # noqa
        if self.indices is not None: d["indices"] = self.indices.to_dict() # noqa
        if self.values is not None: d["values"] = self.values.to_dict() # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AccessorSparse':
        # count do nothing
        if "indices" in src: src["indices"] = AccessorSparseIndices.from_dict(src["indices"]) # noqa
        if "values" in src: src["values"] = AccessorSparseValues.from_dict(src["values"]) # noqa
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return AccessorSparse(**src)


class Accessor(NamedTuple):
    # The datatype of components in the attribute.
    componentType: AccessorComponentType
    # The number of attributes referenced by this accessor.
    count: int
    # Specifies if the attribute is a scalar, vector, or matrix.
    type: AccessorType
    # The index of the bufferView.
    bufferView: Optional[int] = None
    # The offset relative to the start of the bufferView in bytes.
    byteOffset: Optional[int] = None
    # Specifies whether integer data values should be normalized.
    normalized: Optional[bool] = None
    # Maximum value of each component in this attribute.
    max: Optional[List[float]] = None
    # Minimum value of each component in this attribute.
    min: Optional[List[float]] = None
    # Sparse storage of attributes that deviate from their initialization value.
    sparse: Optional[AccessorSparse] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.bufferView is not None: d["bufferView"] = self.bufferView # noqa
        if self.byteOffset is not None: d["byteOffset"] = self.byteOffset # noqa
        if self.componentType is not None: d["componentType"] = self.componentType.to_dict() # noqa
        if self.normalized is not None: d["normalized"] = self.normalized # noqa
        if self.count is not None: d["count"] = self.count # noqa
        if self.type is not None: d["type"] = self.type.to_dict() # noqa
        if self.max: d["max"] = self.max # noqa
        if self.min: d["min"] = self.min # noqa
        if self.sparse is not None: d["sparse"] = self.sparse.to_dict() # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Accessor':
        # bufferView do nothing
        # byteOffset do nothing
        if "componentType" in src: src["componentType"] = AccessorComponentType(src["componentType"]) # noqa
        # normalized do nothing
        # count do nothing
        if "type" in src: src["type"] = AccessorType(src["type"]) # noqa
        if ("max" not in src): src["max"] = [] # noqa
        if ("min" not in src): src["min"] = [] # noqa
        if "sparse" in src: src["sparse"] = AccessorSparse.from_dict(src["sparse"]) # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Accessor(**src)


class AnimationChannelTargetPath(Enum):
    translation = "translation"
    rotation = "rotation"
    scale = "scale"
    weights = "weights"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AnimationChannelTargetPath':
        return AnimationChannelTargetPath(src)


class AnimationChannelTarget(NamedTuple):
    # The name of the node's TRS property to modify, or the "weights" of the Morph Targets it instantiates. For the "translation" property, the values that are provided by the sampler are the translation along the x, y, and z axes. For the "rotation" property, the values are a quaternion in the order (x, y, z, w), where w is the scalar. For the "scale" property, the values are the scaling factors along the x, y, and z axes.
    path: AnimationChannelTargetPath
    # The index of the bufferView.
    node: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.node is not None: d["node"] = self.node # noqa
        if self.path is not None: d["path"] = self.path.to_dict() # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AnimationChannelTarget':
        # node do nothing
        if "path" in src: src["path"] = AnimationChannelTargetPath(src["path"]) # noqa
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return AnimationChannelTarget(**src)


class AnimationChannel(NamedTuple):
    # The index of the bufferView.
    sampler: int
    # The index of the node and TRS property that an animation channel targets.
    target: AnimationChannelTarget
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.sampler is not None: d["sampler"] = self.sampler # noqa
        if self.target is not None: d["target"] = self.target.to_dict() # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AnimationChannel':
        # sampler do nothing
        if "target" in src: src["target"] = AnimationChannelTarget.from_dict(src["target"]) # noqa
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return AnimationChannel(**src)


class AnimationSamplerInterpolation(Enum):
    LINEAR = "LINEAR"
    STEP = "STEP"
    CUBICSPLINE = "CUBICSPLINE"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'AnimationSamplerInterpolation':
        return AnimationSamplerInterpolation(src)


class AnimationSampler(NamedTuple):
    # The index of the bufferView.
    input: int
    # The index of the bufferView.
    output: int
    # Interpolation algorithm.
    interpolation: Optional[AnimationSamplerInterpolation] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.input is not None: d["input"] = self.input # noqa
        if self.interpolation is not None: d["interpolation"] = self.interpolation.to_dict() # noqa
        if self.output is not None: d["output"] = self.output # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AnimationSampler':
        # input do nothing
        if "interpolation" in src: src["interpolation"] = AnimationSamplerInterpolation(src["interpolation"]) # noqa
        # output do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return AnimationSampler(**src)


class Animation(NamedTuple):
    # An array of channels, each of which targets an animation's sampler at a node's property. Different channels of the same animation can't have equal targets.
    channels: List[AnimationChannel]
    # An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target).
    samplers: List[AnimationSampler]
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.channels: d["channels"] = [item.to_dict() for item in self.channels] # noqa
        if self.samplers: d["samplers"] = [item.to_dict() for item in self.samplers] # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Animation':
        src["channels"] = [AnimationChannel.from_dict(item) for item in src["channels"]] if "channels" in src else [] # noqa
        src["samplers"] = [AnimationSampler.from_dict(item) for item in src["samplers"]] if "samplers" in src else [] # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Animation(**src)


class Asset(NamedTuple):
    # The glTF version that this asset targets.
    version: str
    # A copyright message suitable for display to credit the content creator.
    copyright: Optional[str] = None
    # Tool that generated this glTF model.  Useful for debugging.
    generator: Optional[str] = None
    # The minimum glTF version that this asset targets.
    minVersion: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.copyright is not None: d["copyright"] = self.copyright # noqa
        if self.generator is not None: d["generator"] = self.generator # noqa
        if self.version is not None: d["version"] = self.version # noqa
        if self.minVersion is not None: d["minVersion"] = self.minVersion # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Asset':
        # copyright do nothing
        # generator do nothing
        # version do nothing
        # minVersion do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Asset(**src)


class Buffer(NamedTuple):
    # The length of the buffer in bytes.
    byteLength: int
    # The uri of the buffer.
    uri: Optional[str] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.uri is not None: d["uri"] = self.uri # noqa
        if self.byteLength is not None: d["byteLength"] = self.byteLength # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Buffer':
        # uri do nothing
        # byteLength do nothing
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Buffer(**src)


class BufferViewTarget(Enum):
    ARRAY_BUFFER = 34962
    ELEMENT_ARRAY_BUFFER = 34963

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'BufferViewTarget':
        return BufferViewTarget(src)


class BufferView(NamedTuple):
    # The index of the bufferView.
    buffer: int
    # The total byte length of the buffer view.
    byteLength: int
    # The offset into the buffer in bytes.
    byteOffset: Optional[int] = None
    # The stride, in bytes.
    byteStride: Optional[int] = None
    # The target that the GPU buffer should be bound to.
    target: Optional[BufferViewTarget] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.buffer is not None: d["buffer"] = self.buffer # noqa
        if self.byteOffset is not None: d["byteOffset"] = self.byteOffset # noqa
        if self.byteLength is not None: d["byteLength"] = self.byteLength # noqa
        if self.byteStride is not None: d["byteStride"] = self.byteStride # noqa
        if self.target is not None: d["target"] = self.target.to_dict() # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'BufferView':
        # buffer do nothing
        # byteOffset do nothing
        # byteLength do nothing
        # byteStride do nothing
        if "target" in src: src["target"] = BufferViewTarget(src["target"]) # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return BufferView(**src)


class CameraOrthographic(NamedTuple):
    # The floating-point horizontal magnification of the view. Must not be zero.
    xmag: float
    # The floating-point vertical magnification of the view. Must not be zero.
    ymag: float
    # The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`.
    zfar: float
    # The floating-point distance to the near clipping plane.
    znear: float
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.xmag is not None: d["xmag"] = self.xmag # noqa
        if self.ymag is not None: d["ymag"] = self.ymag # noqa
        if self.zfar is not None: d["zfar"] = self.zfar # noqa
        if self.znear is not None: d["znear"] = self.znear # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'CameraOrthographic':
        # xmag do nothing
        # ymag do nothing
        # zfar do nothing
        # znear do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return CameraOrthographic(**src)


class CameraPerspective(NamedTuple):
    # The floating-point vertical field of view in radians.
    yfov: float
    # The floating-point distance to the near clipping plane.
    znear: float
    # The floating-point aspect ratio of the field of view.
    aspectRatio: Optional[float] = None
    # The floating-point distance to the far clipping plane.
    zfar: Optional[float] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.aspectRatio is not None: d["aspectRatio"] = self.aspectRatio # noqa
        if self.yfov is not None: d["yfov"] = self.yfov # noqa
        if self.zfar is not None: d["zfar"] = self.zfar # noqa
        if self.znear is not None: d["znear"] = self.znear # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'CameraPerspective':
        # aspectRatio do nothing
        # yfov do nothing
        # zfar do nothing
        # znear do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return CameraPerspective(**src)


class CameraType(Enum):
    perspective = "perspective"
    orthographic = "orthographic"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'CameraType':
        return CameraType(src)


class Camera(NamedTuple):
    # Specifies if the camera uses a perspective or orthographic projection.
    type: CameraType
    # An orthographic camera containing properties to create an orthographic projection matrix.
    orthographic: Optional[CameraOrthographic] = None
    # A perspective camera containing properties to create a perspective projection matrix.
    perspective: Optional[CameraPerspective] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.orthographic is not None: d["orthographic"] = self.orthographic.to_dict() # noqa
        if self.perspective is not None: d["perspective"] = self.perspective.to_dict() # noqa
        if self.type is not None: d["type"] = self.type.to_dict() # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Camera':
        if "orthographic" in src: src["orthographic"] = CameraOrthographic.from_dict(src["orthographic"]) # noqa
        if "perspective" in src: src["perspective"] = CameraPerspective.from_dict(src["perspective"]) # noqa
        if "type" in src: src["type"] = CameraType(src["type"]) # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Camera(**src)


class ImageMimeType(Enum):
    ImageJpeg = "image/jpeg"
    ImagePng = "image/png"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'ImageMimeType':
        return ImageMimeType(src)


class Image(NamedTuple):
    # The uri of the image.
    uri: Optional[str] = None
    # The image's MIME type. Required if `bufferView` is defined.
    mimeType: Optional[ImageMimeType] = None
    # The index of the bufferView.
    bufferView: Optional[int] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.uri is not None: d["uri"] = self.uri # noqa
        if self.mimeType is not None: d["mimeType"] = self.mimeType.to_dict() # noqa
        if self.bufferView is not None: d["bufferView"] = self.bufferView # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Image':
        # uri do nothing
        if "mimeType" in src: src["mimeType"] = ImageMimeType(src["mimeType"]) # noqa
        # bufferView do nothing
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Image(**src)


class TextureInfo(NamedTuple):
    # The index of the bufferView.
    index: int
    # The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    texCoord: Optional[int] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.index is not None: d["index"] = self.index # noqa
        if self.texCoord is not None: d["texCoord"] = self.texCoord # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'TextureInfo':
        # index do nothing
        # texCoord do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return TextureInfo(**src)


class MaterialPBRMetallicRoughness(NamedTuple):
    # The material's base color factor.
    baseColorFactor: Optional[List[float]] = None
    # Reference to a texture.
    baseColorTexture: Optional[TextureInfo] = None
    # The metalness of the material.
    metallicFactor: Optional[float] = None
    # The roughness of the material.
    roughnessFactor: Optional[float] = None
    # Reference to a texture.
    metallicRoughnessTexture: Optional[TextureInfo] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.baseColorFactor: d["baseColorFactor"] = self.baseColorFactor # noqa
        if self.baseColorTexture is not None: d["baseColorTexture"] = self.baseColorTexture.to_dict() # noqa
        if self.metallicFactor is not None: d["metallicFactor"] = self.metallicFactor # noqa
        if self.roughnessFactor is not None: d["roughnessFactor"] = self.roughnessFactor # noqa
        if self.metallicRoughnessTexture is not None: d["metallicRoughnessTexture"] = self.metallicRoughnessTexture.to_dict() # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MaterialPBRMetallicRoughness':
        if ("baseColorFactor" not in src): src["baseColorFactor"] = [] # noqa
        if "baseColorTexture" in src: src["baseColorTexture"] = TextureInfo.from_dict(src["baseColorTexture"]) # noqa
        # metallicFactor do nothing
        # roughnessFactor do nothing
        if "metallicRoughnessTexture" in src: src["metallicRoughnessTexture"] = TextureInfo.from_dict(src["metallicRoughnessTexture"]) # noqa
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return MaterialPBRMetallicRoughness(**src)


class MaterialNormalTextureInfo(NamedTuple):
    # The index of the bufferView.
    index: int
    # The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    texCoord: Optional[int] = None
    # The scalar multiplier applied to each normal vector of the normal texture.
    scale: Optional[float] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.index is not None: d["index"] = self.index # noqa
        if self.texCoord is not None: d["texCoord"] = self.texCoord # noqa
        if self.scale is not None: d["scale"] = self.scale # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MaterialNormalTextureInfo':
        # index do nothing
        # texCoord do nothing
        # scale do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return MaterialNormalTextureInfo(**src)


class MaterialOcclusionTextureInfo(NamedTuple):
    # The index of the bufferView.
    index: int
    # The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    texCoord: Optional[int] = None
    # A scalar multiplier controlling the amount of occlusion applied.
    strength: Optional[float] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.index is not None: d["index"] = self.index # noqa
        if self.texCoord is not None: d["texCoord"] = self.texCoord # noqa
        if self.strength is not None: d["strength"] = self.strength # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MaterialOcclusionTextureInfo':
        # index do nothing
        # texCoord do nothing
        # strength do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return MaterialOcclusionTextureInfo(**src)


class MaterialAlphaMode(Enum):
    OPAQUE = "OPAQUE"
    MASK = "MASK"
    BLEND = "BLEND"

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'MaterialAlphaMode':
        return MaterialAlphaMode(src)


class Material(NamedTuple):
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None
    # A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology.
    pbrMetallicRoughness: Optional[MaterialPBRMetallicRoughness] = None
    # Reference to a texture.
    normalTexture: Optional[MaterialNormalTextureInfo] = None
    # Reference to a texture.
    occlusionTexture: Optional[MaterialOcclusionTextureInfo] = None
    # Reference to a texture.
    emissiveTexture: Optional[TextureInfo] = None
    # The emissive color of the material.
    emissiveFactor: Optional[List[float]] = None
    # The alpha rendering mode of the material.
    alphaMode: Optional[MaterialAlphaMode] = None
    # The alpha cutoff value of the material.
    alphaCutoff: Optional[float] = None
    # Specifies whether the material is double sided.
    doubleSided: Optional[bool] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        if self.pbrMetallicRoughness is not None: d["pbrMetallicRoughness"] = self.pbrMetallicRoughness.to_dict() # noqa
        if self.normalTexture is not None: d["normalTexture"] = self.normalTexture.to_dict() # noqa
        if self.occlusionTexture is not None: d["occlusionTexture"] = self.occlusionTexture.to_dict() # noqa
        if self.emissiveTexture is not None: d["emissiveTexture"] = self.emissiveTexture.to_dict() # noqa
        if self.emissiveFactor: d["emissiveFactor"] = self.emissiveFactor # noqa
        if self.alphaMode is not None: d["alphaMode"] = self.alphaMode.to_dict() # noqa
        if self.alphaCutoff is not None: d["alphaCutoff"] = self.alphaCutoff # noqa
        if self.doubleSided is not None: d["doubleSided"] = self.doubleSided # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Material':
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        if "pbrMetallicRoughness" in src: src["pbrMetallicRoughness"] = MaterialPBRMetallicRoughness.from_dict(src["pbrMetallicRoughness"]) # noqa
        if "normalTexture" in src: src["normalTexture"] = MaterialNormalTextureInfo.from_dict(src["normalTexture"]) # noqa
        if "occlusionTexture" in src: src["occlusionTexture"] = MaterialOcclusionTextureInfo.from_dict(src["occlusionTexture"]) # noqa
        if "emissiveTexture" in src: src["emissiveTexture"] = TextureInfo.from_dict(src["emissiveTexture"]) # noqa
        if ("emissiveFactor" not in src): src["emissiveFactor"] = [] # noqa
        if "alphaMode" in src: src["alphaMode"] = MaterialAlphaMode(src["alphaMode"]) # noqa
        # alphaCutoff do nothing
        # doubleSided do nothing
        return Material(**src)


class MeshPrimitiveMode(Enum):
    POINTS = 0
    LINES = 1
    LINE_LOOP = 2
    LINE_STRIP = 3
    TRIANGLES = 4
    TRIANGLE_STRIP = 5
    TRIANGLE_FAN = 6

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'MeshPrimitiveMode':
        return MeshPrimitiveMode(src)


class MeshPrimitive(NamedTuple):
    # A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data.
    attributes: Dict[str, int]
    # The index of the bufferView.
    indices: Optional[int] = None
    # The index of the bufferView.
    material: Optional[int] = None
    # The type of primitives to render.
    mode: Optional[MeshPrimitiveMode] = None
    # An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their deviations in the Morph Target.
    targets: Optional[List[Dict[str, int]]] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.attributes is not None: d["attributes"] = self.attributes # noqa
        if self.indices is not None: d["indices"] = self.indices # noqa
        if self.material is not None: d["material"] = self.material # noqa
        if self.mode is not None: d["mode"] = self.mode.to_dict() # noqa
        if self.targets: d["targets"] = self.targets # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'MeshPrimitive':
        if ("attributes" not in src): src["attributes"] = {} # noqa
        # indices do nothing
        # material do nothing
        if "mode" in src: src["mode"] = MeshPrimitiveMode(src["mode"]) # noqa
        if ("targets" not in src): src["targets"] = [] # noqa
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return MeshPrimitive(**src)


class Mesh(NamedTuple):
    # An array of primitives, each defining geometry to be rendered with a material.
    primitives: List[MeshPrimitive]
    # Array of weights to be applied to the Morph Targets.
    weights: Optional[List[float]] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.primitives: d["primitives"] = [item.to_dict() for item in self.primitives] # noqa
        if self.weights: d["weights"] = self.weights # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Mesh':
        src["primitives"] = [MeshPrimitive.from_dict(item) for item in src["primitives"]] if "primitives" in src else [] # noqa
        if ("weights" not in src): src["weights"] = [] # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Mesh(**src)


class Node(NamedTuple):
    # The index of the bufferView.
    camera: Optional[int] = None
    # The indices of this node's children.
    children: Optional[List[int]] = None
    # The index of the bufferView.
    skin: Optional[int] = None
    # A floating-point 4x4 transformation matrix stored in column-major order.
    matrix: Optional[List[float]] = None
    # The index of the bufferView.
    mesh: Optional[int] = None
    # The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.
    rotation: Optional[List[float]] = None
    # The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.
    scale: Optional[List[float]] = None
    # The node's translation along the x, y, and z axes.
    translation: Optional[List[float]] = None
    # The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh.
    weights: Optional[List[float]] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.camera is not None: d["camera"] = self.camera # noqa
        if self.children: d["children"] = self.children # noqa
        if self.skin is not None: d["skin"] = self.skin # noqa
        if self.matrix: d["matrix"] = self.matrix # noqa
        if self.mesh is not None: d["mesh"] = self.mesh # noqa
        if self.rotation: d["rotation"] = self.rotation # noqa
        if self.scale: d["scale"] = self.scale # noqa
        if self.translation: d["translation"] = self.translation # noqa
        if self.weights: d["weights"] = self.weights # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Node':
        # camera do nothing
        if ("children" not in src): src["children"] = [] # noqa
        # skin do nothing
        if ("matrix" not in src): src["matrix"] = [] # noqa
        # mesh do nothing
        if ("rotation" not in src): src["rotation"] = [] # noqa
        if ("scale" not in src): src["scale"] = [] # noqa
        if ("translation" not in src): src["translation"] = [] # noqa
        if ("weights" not in src): src["weights"] = [] # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Node(**src)


class SamplerMagFilter(Enum):
    NEAREST = 9728
    LINEAR = 9729

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerMagFilter':
        return SamplerMagFilter(src)


class SamplerMinFilter(Enum):
    NEAREST = 9728
    LINEAR = 9729
    NEAREST_MIPMAP_NEAREST = 9984
    LINEAR_MIPMAP_NEAREST = 9985
    NEAREST_MIPMAP_LINEAR = 9986
    LINEAR_MIPMAP_LINEAR = 9987

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerMinFilter':
        return SamplerMinFilter(src)


class SamplerWrapS(Enum):
    CLAMP_TO_EDGE = 33071
    MIRRORED_REPEAT = 33648
    REPEAT = 10497

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerWrapS':
        return SamplerWrapS(src)


class SamplerWrapT(Enum):
    CLAMP_TO_EDGE = 33071
    MIRRORED_REPEAT = 33648
    REPEAT = 10497

    def to_dict(self):
        return self.value

    @staticmethod
    def from_dict(src) -> 'SamplerWrapT':
        return SamplerWrapT(src)


class Sampler(NamedTuple):
    # Magnification filter.
    magFilter: Optional[SamplerMagFilter] = None
    # Minification filter.
    minFilter: Optional[SamplerMinFilter] = None
    # s wrapping mode.
    wrapS: Optional[SamplerWrapS] = None
    # t wrapping mode.
    wrapT: Optional[SamplerWrapT] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.magFilter is not None: d["magFilter"] = self.magFilter.to_dict() # noqa
        if self.minFilter is not None: d["minFilter"] = self.minFilter.to_dict() # noqa
        if self.wrapS is not None: d["wrapS"] = self.wrapS.to_dict() # noqa
        if self.wrapT is not None: d["wrapT"] = self.wrapT.to_dict() # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Sampler':
        if "magFilter" in src: src["magFilter"] = SamplerMagFilter(src["magFilter"]) # noqa
        if "minFilter" in src: src["minFilter"] = SamplerMinFilter(src["minFilter"]) # noqa
        if "wrapS" in src: src["wrapS"] = SamplerWrapS(src["wrapS"]) # noqa
        if "wrapT" in src: src["wrapT"] = SamplerWrapT(src["wrapT"]) # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Sampler(**src)


class Scene(NamedTuple):
    # The indices of each root node.
    nodes: Optional[List[int]] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.nodes: d["nodes"] = self.nodes # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Scene':
        if ("nodes" not in src): src["nodes"] = [] # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Scene(**src)


class Skin(NamedTuple):
    # Indices of skeleton nodes, used as joints in this skin.
    joints: List[int]
    # The index of the bufferView.
    inverseBindMatrices: Optional[int] = None
    # The index of the bufferView.
    skeleton: Optional[int] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.inverseBindMatrices is not None: d["inverseBindMatrices"] = self.inverseBindMatrices # noqa
        if self.skeleton is not None: d["skeleton"] = self.skeleton # noqa
        if self.joints: d["joints"] = self.joints # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Skin':
        # inverseBindMatrices do nothing
        # skeleton do nothing
        if ("joints" not in src): src["joints"] = [] # noqa
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Skin(**src)


class Texture(NamedTuple):
    # The index of the bufferView.
    sampler: Optional[int] = None
    # The index of the bufferView.
    source: Optional[int] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.sampler is not None: d["sampler"] = self.sampler # noqa
        if self.source is not None: d["source"] = self.source # noqa
        if self.name is not None: d["name"] = self.name # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'Texture':
        # sampler do nothing
        # source do nothing
        # name do nothing
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return Texture(**src)


class glTF(NamedTuple):
    # Metadata about the glTF asset.
    asset: Asset
    # Names of glTF extensions used somewhere in this asset.
    extensionsUsed: Optional[List[str]] = None
    # Names of glTF extensions required to properly load this asset.
    extensionsRequired: Optional[List[str]] = None
    # An array of accessors.
    accessors: Optional[List[Accessor]] = None
    # An array of keyframe animations.
    animations: Optional[List[Animation]] = None
    # An array of buffers.
    buffers: Optional[List[Buffer]] = None
    # An array of bufferViews.
    bufferViews: Optional[List[BufferView]] = None
    # An array of cameras.
    cameras: Optional[List[Camera]] = None
    # An array of images.
    images: Optional[List[Image]] = None
    # An array of materials.
    materials: Optional[List[Material]] = None
    # An array of meshes.
    meshes: Optional[List[Mesh]] = None
    # An array of nodes.
    nodes: Optional[List[Node]] = None
    # An array of samplers.
    samplers: Optional[List[Sampler]] = None
    # The index of the bufferView.
    scene: Optional[int] = None
    # An array of scenes.
    scenes: Optional[List[Scene]] = None
    # An array of skins.
    skins: Optional[List[Skin]] = None
    # An array of textures.
    textures: Optional[List[Texture]] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Any]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.extensionsUsed: d["extensionsUsed"] = self.extensionsUsed # noqa
        if self.extensionsRequired: d["extensionsRequired"] = self.extensionsRequired # noqa
        if self.accessors: d["accessors"] = [item.to_dict() for item in self.accessors] # noqa
        if self.animations: d["animations"] = [item.to_dict() for item in self.animations] # noqa
        if self.asset is not None: d["asset"] = self.asset.to_dict() # noqa
        if self.buffers: d["buffers"] = [item.to_dict() for item in self.buffers] # noqa
        if self.bufferViews: d["bufferViews"] = [item.to_dict() for item in self.bufferViews] # noqa
        if self.cameras: d["cameras"] = [item.to_dict() for item in self.cameras] # noqa
        if self.images: d["images"] = [item.to_dict() for item in self.images] # noqa
        if self.materials: d["materials"] = [item.to_dict() for item in self.materials] # noqa
        if self.meshes: d["meshes"] = [item.to_dict() for item in self.meshes] # noqa
        if self.nodes: d["nodes"] = [item.to_dict() for item in self.nodes] # noqa
        if self.samplers: d["samplers"] = [item.to_dict() for item in self.samplers] # noqa
        if self.scene is not None: d["scene"] = self.scene # noqa
        if self.scenes: d["scenes"] = [item.to_dict() for item in self.scenes] # noqa
        if self.skins: d["skins"] = [item.to_dict() for item in self.skins] # noqa
        if self.textures: d["textures"] = [item.to_dict() for item in self.textures] # noqa
        if self.extensions is not None: d["extensions"] = self.extensions # noqa
        if self.extras is not None: d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'glTF':
        if ("extensionsUsed" not in src): src["extensionsUsed"] = [] # noqa
        if ("extensionsRequired" not in src): src["extensionsRequired"] = [] # noqa
        src["accessors"] = [Accessor.from_dict(item) for item in src["accessors"]] if "accessors" in src else [] # noqa
        src["animations"] = [Animation.from_dict(item) for item in src["animations"]] if "animations" in src else [] # noqa
        if "asset" in src: src["asset"] = Asset.from_dict(src["asset"]) # noqa
        src["buffers"] = [Buffer.from_dict(item) for item in src["buffers"]] if "buffers" in src else [] # noqa
        src["bufferViews"] = [BufferView.from_dict(item) for item in src["bufferViews"]] if "bufferViews" in src else [] # noqa
        src["cameras"] = [Camera.from_dict(item) for item in src["cameras"]] if "cameras" in src else [] # noqa
        src["images"] = [Image.from_dict(item) for item in src["images"]] if "images" in src else [] # noqa
        src["materials"] = [Material.from_dict(item) for item in src["materials"]] if "materials" in src else [] # noqa
        src["meshes"] = [Mesh.from_dict(item) for item in src["meshes"]] if "meshes" in src else [] # noqa
        src["nodes"] = [Node.from_dict(item) for item in src["nodes"]] if "nodes" in src else [] # noqa
        src["samplers"] = [Sampler.from_dict(item) for item in src["samplers"]] if "samplers" in src else [] # noqa
        # scene do nothing
        src["scenes"] = [Scene.from_dict(item) for item in src["scenes"]] if "scenes" in src else [] # noqa
        src["skins"] = [Skin.from_dict(item) for item in src["skins"]] if "skins" in src else [] # noqa
        src["textures"] = [Texture.from_dict(item) for item in src["textures"]] if "textures" in src else [] # noqa
        if ("extensions" not in src): src["extensions"] = {} # noqa
        if ("extras" not in src): src["extras"] = {} # noqa
        return glTF(**src)


if __name__ == '__main__':
    gltf = glTF()
    print(gltf)
