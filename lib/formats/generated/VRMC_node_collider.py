# this is generated by sukonbu
from typing import NamedTuple, List, Any, Optional, Dict
from enum import Enum

def is_enable(value):
    if isinstance(value, int):
        return True
    if value:
        return True
    return False


class ColliderShapeSphere(NamedTuple):
    # The sphere center. vector3
    offset: Optional[List[float]] = None
    # The sphere radius
    radius: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.offset: d["offset"] = self.offset # noqa
        if is_enable(self.radius): d["radius"] = self.radius # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'ColliderShapeSphere':
        dst = {}
        dst["offset"] = src.get("offset", [])
        if "radius" in src: dst["radius"] = src["radius"] # noqa copy
        return ColliderShapeSphere(**dst)


class ColliderShapeCapsule(NamedTuple):
    # The capsule head. vector3
    offset: Optional[List[float]] = None
    # The capsule radius
    radius: Optional[float] = None
    # The capsule tail. vector3
    tail: Optional[List[float]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.offset: d["offset"] = self.offset # noqa
        if is_enable(self.radius): d["radius"] = self.radius # noqa
        if self.tail: d["tail"] = self.tail # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'ColliderShapeCapsule':
        dst = {}
        dst["offset"] = src.get("offset", [])
        if "radius" in src: dst["radius"] = src["radius"] # noqa copy
        dst["tail"] = src.get("tail", [])
        return ColliderShapeCapsule(**dst)


class ColliderShape(NamedTuple):
    # 
    sphere: Optional[ColliderShapeSphere] = None
    # 
    capsule: Optional[ColliderShapeCapsule] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.sphere): d["sphere"] = self.sphere.to_dict() # noqa
        if is_enable(self.capsule): d["capsule"] = self.capsule.to_dict() # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'ColliderShape':
        dst = {}
        if "sphere" in src: dst["sphere"] = ColliderShapeSphere.from_dict(src["sphere"]) # noqa
        if "capsule" in src: dst["capsule"] = ColliderShapeCapsule.from_dict(src["capsule"]) # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return ColliderShape(**dst)


class VRMC_node_collider(NamedTuple):
    # 
    shapes: Optional[List[ColliderShape]] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if self.shapes: d["shapes"] = [item.to_dict() for item in self.shapes] # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'VRMC_node_collider':
        dst = {}
        dst["shapes"] = [ColliderShape.from_dict(item) for item in src["shapes"]] if "shapes" in src else [] # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return VRMC_node_collider(**dst)


if __name__ == '__main__':
    pass
