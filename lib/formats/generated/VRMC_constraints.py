# this is generated by sukonbu
from typing import NamedTuple, List, Any, Optional, Dict
from enum import Enum

def is_enable(value):
    if isinstance(value, int):
        return True
    if value:
        return True
    return False


class PositionConstraint(NamedTuple):
    # The index of the node constrains the node.
    source: int
    # An enum that specifies an object space.
    sourceSpace: Optional[str] = None
    # An enum that specifies an object space.
    destinationSpace: Optional[str] = None
    # Axes be constrained by this constraint, in X-Y-Z order.
    freezeAxes: Optional[List[bool]] = None
    # The weight of the constraint.
    weight: Optional[float] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.source): d["source"] = self.source # noqa
        if is_enable(self.sourceSpace): d["sourceSpace"] = self.sourceSpace # noqa
        if is_enable(self.destinationSpace): d["destinationSpace"] = self.destinationSpace # noqa
        if self.freezeAxes: d["freezeAxes"] = self.freezeAxes # noqa
        if is_enable(self.weight): d["weight"] = self.weight # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'PositionConstraint':
        dst = {}
        if "source" in src: dst["source"] = src["source"] # noqa copy
        if "sourceSpace" in src: dst["sourceSpace"] = src["sourceSpace"] # noqa copy
        if "destinationSpace" in src: dst["destinationSpace"] = src["destinationSpace"] # noqa copy
        dst["freezeAxes"] = src.get("freezeAxes", [])
        if "weight" in src: dst["weight"] = src["weight"] # noqa copy
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return PositionConstraint(**dst)


class RotationConstraint(NamedTuple):
    # The index of the node constrains the node.
    source: int
    # An enum that specifies an object space.
    sourceSpace: Optional[str] = None
    # An enum that specifies an object space.
    destinationSpace: Optional[str] = None
    # Axes be constrained by this constraint, in X-Y-Z order.
    freezeAxes: Optional[List[bool]] = None
    # The weight of the constraint.
    weight: Optional[float] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.source): d["source"] = self.source # noqa
        if is_enable(self.sourceSpace): d["sourceSpace"] = self.sourceSpace # noqa
        if is_enable(self.destinationSpace): d["destinationSpace"] = self.destinationSpace # noqa
        if self.freezeAxes: d["freezeAxes"] = self.freezeAxes # noqa
        if is_enable(self.weight): d["weight"] = self.weight # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'RotationConstraint':
        dst = {}
        if "source" in src: dst["source"] = src["source"] # noqa copy
        if "sourceSpace" in src: dst["sourceSpace"] = src["sourceSpace"] # noqa copy
        if "destinationSpace" in src: dst["destinationSpace"] = src["destinationSpace"] # noqa copy
        dst["freezeAxes"] = src.get("freezeAxes", [])
        if "weight" in src: dst["weight"] = src["weight"] # noqa copy
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return RotationConstraint(**dst)


class AimConstraint(NamedTuple):
    # The index of the node constrains the node.
    source: int
    # An enum that specifies an object space.
    sourceSpace: Optional[str] = None
    # An enum that specifies an object space.
    destinationSpace: Optional[str] = None
    # An axis which faces the direction of its sources.
    aimVector: Optional[List[float]] = None
    # An up axis of the constraint.
    upVector: Optional[List[float]] = None
    # Axes be constrained by this constraint, in Yaw-Pitch order.
    freezeAxes: Optional[List[bool]] = None
    # The weight of the constraint.
    weight: Optional[float] = None
    # The user-defined name of this object.
    name: Optional[str] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.source): d["source"] = self.source # noqa
        if is_enable(self.sourceSpace): d["sourceSpace"] = self.sourceSpace # noqa
        if is_enable(self.destinationSpace): d["destinationSpace"] = self.destinationSpace # noqa
        if self.aimVector: d["aimVector"] = self.aimVector # noqa
        if self.upVector: d["upVector"] = self.upVector # noqa
        if self.freezeAxes: d["freezeAxes"] = self.freezeAxes # noqa
        if is_enable(self.weight): d["weight"] = self.weight # noqa
        if is_enable(self.name): d["name"] = self.name # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'AimConstraint':
        dst = {}
        if "source" in src: dst["source"] = src["source"] # noqa copy
        if "sourceSpace" in src: dst["sourceSpace"] = src["sourceSpace"] # noqa copy
        if "destinationSpace" in src: dst["destinationSpace"] = src["destinationSpace"] # noqa copy
        dst["aimVector"] = src.get("aimVector", [])
        dst["upVector"] = src.get("upVector", [])
        dst["freezeAxes"] = src.get("freezeAxes", [])
        if "weight" in src: dst["weight"] = src["weight"] # noqa copy
        if "name" in src: dst["name"] = src["name"] # noqa copy
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return AimConstraint(**dst)


class VRMC_constraintsExtension(NamedTuple):
    # A constraint that links the position with sources.
    position: Optional[PositionConstraint] = None
    # A constraint that links the rotation with sources.
    rotation: Optional[RotationConstraint] = None
    # A constraint that rotates the node to face sources.
    aim: Optional[AimConstraint] = None
    # Dictionary object with extension-specific objects.
    extensions: Optional[Dict[str, Dict[str, Any]]] = None
    # Application-specific data.
    extras: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {}
        if is_enable(self.position): d["position"] = self.position.to_dict() # noqa
        if is_enable(self.rotation): d["rotation"] = self.rotation.to_dict() # noqa
        if is_enable(self.aim): d["aim"] = self.aim.to_dict() # noqa
        if is_enable(self.extensions): d["extensions"] = self.extensions # noqa
        if is_enable(self.extras): d["extras"] = self.extras # noqa
        return d

    @staticmethod
    def from_dict(src: dict) -> 'VRMC_constraintsExtension':
        dst = {}
        if "position" in src: dst["position"] = PositionConstraint.from_dict(src["position"]) # noqa
        if "rotation" in src: dst["rotation"] = RotationConstraint.from_dict(src["rotation"]) # noqa
        if "aim" in src: dst["aim"] = AimConstraint.from_dict(src["aim"]) # noqa
        dst["extensions"] = src.get("extensions", {})
        dst["extras"] = src.get("extras", {})
        return VRMC_constraintsExtension(**dst)


if __name__ == '__main__':
    pass
